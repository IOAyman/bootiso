#!/bin/bash
# shellcheck disable=SC2181
# shellcheck disable=SC2236
#
# Author: jules randolph <jules.sam.randolph@gmail.com> https://github.com/jsamr
# License: MIT
# Version 4.0.0-alpha.0

set -o pipefail
set -E

version="4.0.0-alpha.0"
scriptName=$(basename "$0")
bashVersion=$(echo "$BASH_VERSION" | cut -d. -f1)

if [ -z "$BASH_VERSION" ] || [ "$bashVersion" -lt 4 ]; then
  echo >&2 "You need bash v4+ to run this script. Aborting..."
  exit 1
fi

#                                              .
#                                            .o8
#  .ooooo.   .ooooo.  ooo. .oo.    .oooo.o .o888oo
# d88' `"Y8 d88' `88b `888P"Y88b  d88(  "8   888
# 888       888   888  888   888  `"Y88b.    888
# 888   .o8 888   888  888   888  o.  )88b   888 .
# `Y8bod8P' `Y8bod8P' o888o o888o 8""888P'   "888"
#
# Global constant declarations

# PROGRAM CONSTANTS
typeset -r prog_syslinuxLibRoot=${BOOTISO_SYSLINUX_LIB_ROOT:-'/usr/lib/syslinux'}
typeset -r prog_mountRoot=/mnt
typeset -r prog_tempRoot=/var/tmp/bootiso
typeset -r prog_cacheRoot=/var/cache/bootiso
typeset -ar prog_commandDependencies=('lsblk' 'column' 'sfdisk' 'blkid' 'wipefs' 'blockdev' 'grep' 'file' 'awk' 'mlabel' 'syslinux' 'rsync'
  'partx' 'curl' 'cat' 'tar' 'bc' 'wimlib-imagex' 'md5sum' 'sha1sum' 'sha256sum' 'sha512sum' 'cut' 'jq')
typeset -Ar prog_commandPackages=(
  ['lsblk']='util-linux'
  ['mount']='util-linux'
  ['umount']='util-linux'
  ['sfdisk']='util-linux'
  ['blkid']='util-linux'
  ['wipefs']='util-linux'
  ['blockdev']='util-linux'
  ['column']='util-linux'
  ['blockdev']='util-linux'
  ['partx']='util-linux'
  ['grep']='grep'
  ['sed']='sed'
  ['file']='file'
  ['awk']='gawk'
  ['mlabel']='mtools'
  ['syslinux']='syslinux'
  ['rsync']='rsync'
  ['curl']='curl'
  ['tar']='tar'
  ['bc']='bc'
  ['wimlib-imagex']='wimlib'
  ['jq']='jq'
  ['find']='findutils'
  ['find']='findutils'
  ['md5sum']='coreutils'
  ['sha1sum']='coreutils'
  ['sha256sum']='coreutils'
  ['sha512sum']='coreutils'
  ['cut']='coreutils'
  ['cat']='coreutils'
  ['mkdir']='coreutils'
  ['chmod']='coreutils'
  ['dirname']='coreutils'
  ['basename']='coreutils'
  ['date']='coreutils'
  ['tr']='coreutils'
)
typeset -r prog_shortOptions='bydJahlMftLpD'
typeset -ar prog_supportedFS=('vfat' 'exfat' 'ntfs' 'ext2' 'ext3' 'ext4' 'f2fs')
typeset -Ar prog_userVarsCompatibilityMatrix=(
  ['iso-file']='install-auto install-mount-rsync install-image-copy inspect probe'
  ['hash-file']='install-auto install-mount-rsync install-image-copy inspect probe'
  [device]='install-auto install-mount-rsync install-image-copy format'
  [type]='install-mount-rsync format'
  [label]='install-mount-rsync format'
  ['remote-bootloader']='install-mount-rsync'
  ['part-type']='format install-mount-rsync'
  ['dd-bs']='install-image-copy'
  ['data-part-fs']='install-image-copy'
)
typeset -Ar prog_userFlagsCompatibilityMatrix=(
  ['assume-yes']='install-auto install-mount-rsync install-image-copy format'
  ['no-eject']='install-auto install-mount-rsync install-image-copy format'
  ['autoselect']='install-auto install-mount-rsync install-image-copy format'
  ['no-mime-check']='install-auto install-mount-rsync install-image-copy probe inspect'
  ['no-hash-check']='install-auto install-mount-rsync install-image-copy probe inspect'
  ['force-hash-check']='install-auto install-mount-rsync install-image-copy probe inspect'
  ['no-usb-check']='install-auto install-mount-rsync install-image-copy list-usb-drives probe format'
  ['no-size-check']='install-auto install-mount-rsync install-image-copy'
  [gpt]='format install-mount-rsync'
  ['data-part']='install-image-copy'
  # Mount-Rsync specials
  ['local-bootloader']='install-mount-rsync'
  ['no-wimsplit']='install-mount-rsync'
)
typeset -Ar prog_exitStatus=(
  # Exceptions
  [ASSERTFAIL]=1
  [SYNOPSISNC]=2
  [MISBOOTCAP]=3
  [MISFILE]=4
  [BADFILE]=5
  [MISDEV]=6
  [BADDEV]=7
  [NODEV]=8
  [MISDEP]=9
  [HOSTUNR]=10
  [USERABORT]=11
  [MISPRIVILEGE]=12
  # Errors
  [INTERNALIO]=64
  [INTERNALST]=65
  [INTERNALTP]=66
)
typeset -r prog_ticketsurl="https://github.com/jsamr/bootiso/issues"
typeset -r prog_openTicketMessage="This is not expected: please open a ticket at $prog_ticketsurl."

# FS CONSTANTS
typeset -Ar fs_gptPartitionCodes=(
  [efi]="C12A7328-F81F-11D2-BA4B-00A0C93EC93B"
  # Windows Data partition
  [wdp]="EBD0A0A2-B9E5-4433-87C0-68B6B72699C7"
  # Linux Filesystem Data
  [lfd]="0FC63DAF-8483-4772-8E79-3D69D8477DE4"
)
typeset -Ar fs_mbrPartitionCodes=(
  [efi]=ef
)

# TERMINAL CONSTANTS
# See console_codes GNU-Linux man page
typeset -r term_setRed="\e[31m"
typeset -r term_setGreen="\e[32m"
typeset -r term_setYellow="\e[33m"
typeset -r term_unsetColor="\e[39m"
typeset -r term_setUnderline="\e[4m"
typeset -r term_unsetUnderline="\e[24m"
typeset -r term_setBold="\e[1m"
typeset -r term_unsetBold="\e[22m"
# Padding
typeset -r term_logPrefix="$scriptName: "
typeset -r term_logPrefixLength="${#term_logPrefix}"
typeset -r term_logPrefixEmpty="$(printf "%${term_logPrefixLength}s")"

# oooo    ooo  .oooo.   oooo d8b  .oooo.o
#  `88.  .8'  `P  )88b  `888""8P d88(  "8
#   `88..8'    .oP"888   888     `"Y88b.
#    `888'    d8(  888   888     o.  )88b
#     `8'     `Y888""8o d888b    8""888P'
#
# Global variables declarations

# INTERNAL VARIABLES
typeset targetPartition
typeset transientElToritoMountPoint
typeset transientUsbMountPoint
typeset transientStartTime
typeset transientEndTime
typeset transientShouldInstallSyslinux=false
typeset syslinuxVersion
typeset completedAction
typeset expectingISOFile
typeset foundSyslinuxMbrBinary
typeset foundSyslinuxBiosFolder
typeset -A syslinuxInstall
typeset -a temporaryAssets=()
typeset -a devicesList=()
typeset -A isoInspections=(
  [syslinuxBin]=''
  [syslinuxVer]=''
  [syslinuxConf]=''
  [isHybrid]=false
  [supportsEFIBoot]=false
  [supportsBIOSBoot]=false
  [hasWimFile]=false
)
typeset -A userFlags=(
  # Actions
  ['help']=''
  ['version']=''
  ['list-usb-drives']=''
  ['format']=''
  ['install-image-copy']=''
  ['install-mount-rsync']=''
  ['inspect']=''
  ['probe']=''
  # Options
  ['local-bootloader']=''
  ['assume-yes']=''
  ['device']=''
  ['no-eject']=''
  ['gpt']=''
  ['autoselect']=''
  ['no-mime-check']=''
  ['no-usb-check']=''
  ['no-size-check']=''
  ['no-hash-check']=''
  ['force-hash-check']=''
  ['no-wimsplit']=''
  ['data-part']=''
)
typeset -A userVars=(
  ['iso-file']=''
  ['hash-file']=''
  ['device']=''
  ['fs']=''
  ['label']=''
  ['remote-bootloader']=''
  ['part-type']=''
  ['data-part-fs']=''
)

# USER VARIABLES
typeset sourceImageFile # no default
typeset sourceHashFile
typeset targetDevice   # default to prompted to user
typeset targetPartitionLabel   # default inferred from image file label
typeset targetFilesystem   # default to vfat
typeset targetPartitionScheme  # GPT or MBR partition type
typeset targetAction='install-auto'
typeset targetBootloaderVersion # default to auto

# USER OPTIONS
typeset disableMimeCheck
typeset disableUSBCheck
typeset disableSizeCheck
typeset disableConfirmation
typeset disableHashCheck
typeset forceHashCheck
typeset disableWimsplit
typeset autoselect
typeset shouldMakePartition
typeset noDeviceEjection
typeset localBootloader
typeset enforceGPT
typeset ddBusSize
typeset enableDataPart
typeset dataPartFstype

#                      o8o
#                      `"'
# oo.ooooo.  oooo d8b oooo  ooo. .oo.  .oo.
#  888' `88b `888""8P `888  `888P"Y88bP"Y88b
#  888   888  888      888   888   888   888
#  888   888  888      888   888   888   888
#  888bod8P' d888b    o888o o888o o888o o888o
#  888
# o888o
#
# PRIM MODULE
#
# Utilities for primitives, that is generic operations
# on bash primitive types such as strings, arrays, integers...
# Functions belonging to this module are prefixed with "prim_"

prim_compute() {
  local _answer
  _answer=$(echo "$@" | bc)
  if ((_answer == 0)); then
    return 1
  else
    return 0
  fi
}

# $1 : The string by which elements will be joined.
# $2+: the elements to join
prim_joinBy() {
  local -r IFS=$1
  shift
  echo "$*"
}

# $1 : The element to check.
# $2+: the list to check against.
prim_containsElement() {
  local -r _match="$1"
  local _arg
  shift
  for _arg in "$@"; do [[ "$_arg" == "$_match" ]] && return 0; done
  return 1
}

# $1: fsType
prim_normalizeFSType() {
  local -r _fsType="${1:-vfat}"
  if [ "${_fsType,,}" == fat32 ]; then
    echo vfat
  else
    echo "$_fsType"
  fi
}

#     .
#   .o8
# .o888oo  .ooooo.  oooo d8b ooo. .oo.  .oo.
#   888   d88' `88b `888""8P `888P"Y88bP"Y88b
#   888   888ooo888  888      888   888   888
#   888 . 888    .o  888      888   888   888
#   "888" `Y8bod8P' d888b    o888o o888o o888o
#
# TERM MODULE
#
# Terminal utilities
# Functions belonging to this module
# are prefixed with "term_"

term_boldify() {
  echo -e "$term_setBold$1$term_unsetBold"
}

term_underline() {
  echo -e "$term_setUnderline$1$term_unsetUnderline"
}

# $1: The text to colorify.
term_redify() {
  echo -e "$term_setRed$1$term_unsetColor"
}

# $1: The text to colorify.
term_greenify() {
  echo -e "$term_setGreen$1$term_unsetColor"
}

# $1: The text to colorify.
term_yellowify() {
  echo -e "$term_setYellow$1$term_unsetColor"
}

term_printColumn() {
  local -r _prefix=$1
  local -r _prefixLength=$2
  local _termWidth
  local _sep='\t'
  _termWidth="$(tput cols)"
  shift 2
  local _rawInput="$*"
  echo -n -e "$_prefix$_sep$_prefixLength$_sep$_termWidth$_sep$_rawInput" | awk -F $_sep '
{
  prefix = $1
  prefixlen = $2
  termwidth = $3
  len = prefixlen
  printargfill = sprintf("%s%s%s", "%-", prefixlen, "s")
  printf printargfill, prefix
  for(j=4;j<=NF;j++) {
    n = split($j,x," ")
    for(i=1;i<=n;i++){
      if(len+length(x[i])>=termwidth){
        print ""
        printf printargfill, " "
        len = prefixlen
      }
      printf "%s ",x[i]
      len += 1+length(x[i])
    }
  }
  print ""
}'
}

term_printLog() {
  term_printColumn "$term_logPrefix" "$term_logPrefixLength" "$*"
}

# shellcheck disable=SC2120
term_indentAll() {
  while read -r line; do
    term_printColumn " " "$term_logPrefixLength" "$line"
  done < "${1:-/dev/stdin}"
}

# $*: The message to print.
term_echoerr() {
  term_redify "$(term_printLog "$*")"
}

# $*: The message to print.
term_echowarn() {
  term_yellowify "$(term_printLog "$*")"
}

# $*: The message to print.
term_echogood() {
  term_greenify "$(term_printLog "$*")"
}

# $*: The message to print.
term_echoinfo() {
  term_printLog "$*"
}

# Print an ASCII "spin" character
# depending on the modulo of variable _i in scope,
# and sleep for 250ms.
term_updateProgress() {
  local _sp="/-\\|"
  # print when launched from terminal
  if tty -s; then
    printf "\\b%s" "${_sp:_i++%${#_sp}:1}"
  fi
  sleep 0.25
}

term_cleanProgress() {
  # print when launched from terminal
  if tty -s; then
    printf "\\b%s\\n" " "
  fi
}

#  .o88o.
#  888 `"
# o888oo   .oooo.o
#  888    d88(  "8
#  888    `"Y88b.
#  888    o.  )88b
# o888o   8""888P'
#
# FS MODULE
#
# Filesystem operations and utilities.
# Functions belonging to this module
# are prefixed with "fs_"

fs_configureFolders() {
  local _defaultMode=777
  if [ ! -e "$prog_tempRoot" ]; then
    mkdir -m $_defaultMode "$prog_tempRoot"
  elif [ -d "$prog_tempRoot" ]; then
    chmod -R $_defaultMode "$prog_tempRoot"
  else
    prog_failAndExit "${prog_exitStatus[INTERNALST]}" "(fs_configureFolders) '$prog_tempRoot' is not a folder." \
      "Remove this file and try again."
  fi
  if [ ! -e "$prog_cacheRoot" ]; then
    mkdir -m $_defaultMode "$prog_cacheRoot"
  elif [ -d "$prog_cacheRoot" ]; then
    chmod -R $_defaultMode "$prog_cacheRoot"
  else
    prog_failAndExit "${prog_exitStatus[INTERNALST]}" "(fs_configureFolders) '$prog_cacheRoot' is not a folder." \
      "Remove this file and try again."
  fi
  if [ ! -e "$prog_mountRoot" ]; then
    mkdir "$prog_mountRoot"
  elif [ ! -d "$prog_mountRoot" ]; then
    prog_failAndExit "${prog_exitStatus[INTERNALST]}" "(fs_configureFolders) '$prog_mountRoot' is not a folder." \
      "Remove this file and try again."
  fi
}

fs_firstMatchInFolder() {
  local -r _path=$1
  local -r _pattern=$2
  find "$_path" -type f -iname "$_pattern" -print -quit
}

# $1 : from path
# $2+: patterns (see find -iname)
fs_matchFirstExpression() {
  local -r _path=$1
  local _pattern
  local _match
  shift
  for _pattern in "$@"; do
    _match=$(fs_firstMatchInFolder "$_path" "$_pattern")
    if [ ! -z "$_match" ]; then
      echo "$_match"
      break
    fi
  done
}

# $1 : from path
# $2+: path segments (see find -path)
fs_findFileFromPatterns() {
  local -r _path=$1
  shift
  local _pathSegment
  local _found
  local _candidate
  for _pathSegment in "$@"; do
    if [ -f "${_path}/$_pathSegment" ]; then
      _found="${_path}/$_pathSegment"
      break
    fi
  done
  if [ -z "$_found" ]; then
    for _pathSegment in "$@"; do
      _candidate=$(find "$_path" -type f -path "*/$_pathSegment" -print -quit)
      if [ ! -z "$_candidate" ]; then
        _found="$_candidate"
        break
      fi
    done
  fi
  echo "$_found"
}

fs_createTempFile() {
  local -r _prefix=$1
  local _tmpFileTemplate="$prog_tempRoot/$_prefix-XXX" _status
  mktemp "$_tmpFileTemplate"
  _status=$?
  if [ ! $_status -eq 0 ]; then
    prog_failAndExit "${prog_exitStatus[INTERNALIO]}" "Failed to create temporary file."
  fi
}

# $1 : the folder name prefix
# print the name of the new folder if operation succeeded, fails otherwise
fs_createMountFolder() {
  local _tmpFileTemplate _status
  if ((EUID == 0)); then
    _tmpFileTemplate="$prog_mountRoot/$1-XXX"
  else
    _tmpFileTemplate="$prog_tempRoot/$1-XXX"
  fi
  mktemp -d "$_tmpFileTemplate"
  _status=$?
  if [ ! $_status -eq 0 ]; then
    prog_failAndExit "${prog_exitStatus[INTERNALIO]}" "Failed to create temporary mount point with pattern '$_tmpFileTemplate'."
  fi
}

fs_syncdev() {
  sync
}

fs_isMounted() {
  local -r _partitionBlock=$1
  if [ ! -z "$_partitionBlock" ] && grep -q -e "$_partitionBlock" /etc/mtab; then
    return 0
  else
    return 1
  fi
}

fs_umountUSB() {
  if fs_isMounted "$transientUsbMountPoint"; then
    if umount "$transientUsbMountPoint" |& term_indentAll; then
      term_echogood "USB device partition succesfully unmounted."
    else
      term_echowarn "Could not unmount USB mount point."
    fi
  fi
}

# $1: mountPoint
fs_umountPartition() {
  local -r _mountPoint="$1"
  if fs_isMounted "$_mountPoint"; then
    if ! umount "$_mountPoint" |& term_indentAll; then
      term_echowarn "Could not unmount image mount point."
    fi
  fi
}

fs_umountElTorito() {
  if fs_isMounted "$transientElToritoMountPoint"; then
    if ! umount "$transientElToritoMountPoint" |& term_indentAll; then
      term_echowarn "Could not unmount image mount point."
    fi
  fi
}

fs_mountUSB() {
  local _type="$targetFilesystem"
  transientUsbMountPoint=$(fs_createMountFolder usb) || exit "$?"
  temporaryAssets+=("$transientUsbMountPoint")
  term_echoinfo "Created USB device mount point at '$transientUsbMountPoint'"
  if ! mount -t "$_type" "$targetPartition" "$transientUsbMountPoint" > /dev/null; then
    prog_failAndExit "${prog_exitStatus[INTERNALIO]}" "Could not mount USB device."
  fi
}

# $1: mountPoint
fs_mountElToritoFile() {
  local -r _mountPoint="$1"
  if ! mount -r -o loop -- "$sourceImageFile" "$_mountPoint" > /dev/null; then
    prog_failAndExit "${prog_exitStatus[INTERNALIO]}" "Could not mount image file."
  else
    temporaryAssets+=("$_mountPoint")
  fi
}

# $1: fstype
# $2: target partition full path
# $3: partition label
fs_formatPartition() {
  local -r _fstype=$1
  local -r _targetPart=$2
  local -r _partLabel=$3
  # These options always end up with the label flag setter
  local -Ar _mkfsOpts=(
    ['vfat']="-v -F 32 -n" # Fat32 mode
    ['exfat']="-n"
    ['ntfs']="-Q -c 4096 -L" # Quick mode + cluster size = 4096 for Syslinux support
    ['ext2']="-O ^64bit -L"  # Disabling pure 64 bits compression for syslinux compatibility
    ['ext3']="-O ^64bit -L"  # see https://www.syslinux.org/wiki/index.php?title=Filesystem#ext
    ['ext4']="-O ^64bit -L"
    ['f2fs']="-l"
  )
  # format
  term_echogood "Creating $_fstype partition on '$_targetPart'..."
  # shellcheck disable=SC2086
  "mkfs.$targetFilesystem" ${_mkfsOpts[$_fstype]} "$_partLabel" "$_targetPart" |&
    term_indentAll ||
    prog_failAndExit "${prog_exitStatus[INTERNALIO]}" "Failed to create $_fstype partition on USB device."
}

# Given a partition scheme (1), output a partition type
# that would be a good fit for filesystem type (2).
#
# $1 partScheme
# $2 fsType
fs_inferFSType() {
  local -r _partScheme=$1
  local -r _fsType=$2
  local -Ar _gptTypeCodes=(
    ['vfat']="${fs_gptPartitionCodes[wdp]}"
    ['exfat']="${fs_gptPartitionCodes[wdp]}"
    ['ntfs']="${fs_gptPartitionCodes[wdp]}"
    ['ext2']="${fs_gptPartitionCodes[lfd]}"
    ['ext3']="${fs_gptPartitionCodes[lfd]}"
    ['ext4']="${fs_gptPartitionCodes[lfd]}"
    ['f2fs']="${fs_gptPartitionCodes[lfd]}"
  )
  local -Ar _mbrTypeCodes=(
    ['vfat']='c'
    ['exfat']='7'
    ['ntfs']='7'
    ['ext2']='83'
    ['ext3']='83'
    ['ext4']='83'
    ['f2fs']='83'
  )
  case "$_partScheme" in
  dos | mbr) echo "${_mbrTypeCodes[$_fsType]}" ;;
  gpt) echo "${_gptTypeCodes[$_fsType]}" ;;
  *) prog_failAndExit "${prog_exitStatus[INTERNALST]}" "unhandled partition scheme: $_partScheme" ;;
  esac
}

fs_syncWithProgress() {
  # _i must be defined for term_updateProgress
  local -i _i=1
  local -i _status
  local _syncPid
  local _statusFile
  _statusFile=$(fs_createTempFile "bootiso-sync-status")
  temporaryAssets+=("$_statusFile")
  fs_syncdev &
  _syncPid=$!
  echo -n "$scriptName: Synchronizing writes on device '${targetDevice}'   "
  while [ -e "/proc/$_syncPid" ]; do
    term_updateProgress
  done
  term_cleanProgress
  _status=$(cat "$_statusFile")
  if [ ! "$_status" -eq 0 ]; then
    prog_failAndExit "${prog_exitStatus[INTERNALIO]}" "Sync call failed."
  fi
}

#                                 .
#                               .o8
#  .oooo.    .oooo.o oooo d8b .o888oo
# `P  )88b  d88(  "8 `888""8P   888
#  .oP"888  `"Y88b.   888       888
# d8(  888  o.  )88b  888       888 .
# `Y888""8o 8""888P' d888b      "888"
#
# ASRT MODULE
#
# Assertion directives module.
# Functions belonging to this module
# are prefixed with "asrt_"

asrt_checkSudo() {
  if ((EUID != 0)); then
    if [[ -t 1 ]] && prog_hasPackage sudo; then
      sudo --preserve-env "$0" "$@"
    elif prog_hasPackage gksu; then
      exec 1> output_file
      gksu --preserve-env "$0" "$@"
    else
      prog_failAndExit "${prog_exitStatus[MISPRIVILEGE]}" "You must run $scriptName as root."
    fi
    exit
  fi
}

asrt_checkFileIsImage() {
  local _mimeType
  if [ -z "$sourceImageFile" ]; then
    term_echoerr "Missing argument 'iso-file'."
    exit 2
  fi
  if [ -d "$sourceImageFile" ]; then
    prog_failAndExit "${prog_exitStatus[BADFILE]}" "Provided file '$sourceImageFile' is a directory."
  fi
  if [ ! -f "$sourceImageFile" ]; then
    prog_failAndExit "${prog_exitStatus[MISFILE]}" "Provided iso file '$sourceImageFile' does not exist."
  fi
  if [ "$disableMimeCheck" == false ]; then
    _mimeType=$(file --mime-type -b -- "$sourceImageFile")
    if [[ "$_mimeType" != "application/octet-stream" && "$_mimeType" != "application/x-iso9660-image" ]]; then
      term_echoerr "Provided file '$sourceImageFile' doesn't seem to be an image file (wrong mime-type: '$_mimeType')." \
        "You can bypass this policy with $(term_boldify '-M, --no-mime-check')."
      prog_failAndExit "${prog_exitStatus[BADFILE]}"
    fi
  fi
}

asrt_checkImageHash() {
  local _lHash
  local _numValidHashes=0
  local _isoDirectory
  local _isoFileName
  local -ar _hashes=("md5sum" "sha1sum" "sha256sum" "sha512sum")
  _computeHashWithProgress() {
    local _hashName="$1"
    local _imageName="$2"
    # _i must be defined for term_updateProgress
    local _hashStoreFile _i
    _hashStoreFile=$(fs_createTempFile "bootiso-file-_hash")
    term_echoinfo "Checking _hash for '$_imageName'..."
    printf "%s" \
      "You can disable this check with $(term_boldify "-H, --no-_hash-check") flags." | term_indentAll
    temporaryAssets+=("$_hashStoreFile")
    ( 
      local _hash
      local -i _status=0
      _hash=$($_hashName "$_imageName" | awk "{print \$1; exit }")
      _status=$?
      if ((_status == 0)); then
        printf "%s" "$_hash" > "$_hashStoreFile"
      else
        printf "%s" 1 > "$_hashStoreFile"
      fi
    ) &
    pid=$!
    while [ -e "/proc/$pid" ]; do
      term_updateProgress
    done
    term_cleanProgress
    _lHash=$(cat "$_hashStoreFile")
    if [ "$_lHash" == "1" ]; then
      return 1
    fi
  }
  _checkHash() {
    local -r _hashPath=$1  # Path to file containing _hashes
    local -r _imageName=$2 # File to be checked
    local -r _hashName=$3  # Name of command of _hash
    local _status _answer
    # Hash from _hash file
    local _gHash
    _gHash=$(awk -v pattern="$_imageName$" '$0 ~ pattern { print $1; exit }' "$_hashPath")
    if [ -z "$_gHash" ]; then
      term_echoerr "No matching filename found in _hash file '$_hashPath'"
      return
    elif [ -z "$_hashName" ]; then
      case ${#_gHash} in
      32)
        _hashName="md5sum"
        ;;
      40)
        _hashName="sha1sum"
        ;;
      64)
        _hashName="sha256sum"
        ;;
      128)
        _hashName="sha512sum"
        ;;
      *)
        prog_failAndExit "${prog_exitStatus[BADFILE]}" "Matching line in '$_hashPath' has an unexpected _hash format."
        ;;
      esac
    fi
    # Hash from iso
    _computeHashWithProgress $_hashName "$_imageName"
    _status=$?
    if ((_status != 0)); then
      prog_failAndExit "${prog_exitStatus[INTERNALTP]}" "$_hashName command failed with _status $_status"
    fi
    if [ "$_gHash" != "$_lHash" ]; then
      if [ "$forceHashCheck" == 'true' ]; then
        prog_failAndExit "${prog_exitStatus[ASSERTFAIL]}" "Hash mismatch in '$_hashPath' (${_hashName%sum})."
      else
        term_echowarn "Hash mismatch in '$_hashPath' (${_hashName%sum})."
        read -r -n1 -p "${term_logPrefixEmpty}Do you still want to continue? (y/n)> " _answer
        echo
        case $_answer in
        y | Y)
          return
          ;;
        *)
          prog_failAndExit "${prog_exitStatus[USERABORT]}"
          ;;
        esac
        term_echoinfo "Ignoring mismatching _hash."
      fi
    else
      term_echogood "Matching ${_hashName%sum} _hash found in '$_hashPath'"
      _numValidHashes=$((_numValidHashes + 1))
    fi
  }
  _isoDirectory=$(dirname "$sourceImageFile")
  _isoFileName=$(basename "$sourceImageFile")
  if [ -n "$sourceHashFile" ]; then
    if [ -f "$sourceHashFile" ]; then
      _checkHash "$sourceHashFile" "$_isoFileName"
    else
      prog_failAndExit "${prog_exitStatus[MISFILE]}" "Specified _hash file '$sourceHashFile' does not exist."
    fi
  else
    shopt -s nullglob nocaseglob
    for _hash in "${_hashes[@]}"; do
      for file in "$_isoDirectory/$_hash"*; do
        _checkHash "$file" "$_isoFileName" "$_hash"
      done

      if [ -f "$sourceImageFile.${_hash%sum}" ]; then
        _checkHash "$sourceImageFile.${_hash%sum}" "$_isoFileName" "$_hash"
      fi
    done
    shopt -u nullglob nocaseglob
  fi

  if [ "$forceHashCheck" == 'true' ] && [ $_numValidHashes == 0 ]; then
    prog_failAndExit "${prog_exitStatus[ASSERTFAIL]}" "No matching _hashes found. Assert forced by $(term_boldify '--force-_hash-check')"
  fi
}

asrt_checkPackages() {
  local _pkg
  for _pkg in "${prog_commandDependencies[@]}"; do
    prog_checkPkg "$_pkg"
  done
  # test grep supports -P option
  if ! echo 1 | grep -P '1' &> /dev/null; then
    prog_failAndExit "${prog_exitStatus[MISDEP]}" \
      "You're using an old version of grep which does not support perl regular expression (-P option)."
  fi
}

asrt_checkDeviceIsOK() {
  local -r _deviceBlock=$1
  _failDevice() {
    term_echoerr "$1"
    exec_listUSBDrives
    term_echoerr "Exiting..."
    exit "${prog_exitStatus[MISDEV]}"
  }
  if [ ! -e "$_deviceBlock" ]; then
    _failDevice "The selected device '$_deviceBlock' does not exist."
  fi
  if [ ! -b "$_deviceBlock" ]; then
    _failDevice "The selected device '$_deviceBlock' is not a valid block file."
  fi
  if [ ! -d "/sys/block/$(basename "$_deviceBlock")" ] || ! devi_deviceIsDisk "$_deviceBlock"; then
    prog_failAndExit "${prog_exitStatus[BADDEV]}" \
      "The selected device '$_deviceBlock' is either unmounted or not a disk (might be a partition or loop)." \
      "Select a disk instead or reconnect the USB _deviceBlock." \
      "You can check the availability of USB drives with $(term_boldify "$scriptName -l")."
  fi
}

asrt_checkDeviceIsUSB() {
  local _deviceType
  if [ "$disableUSBCheck" == 'true' ]; then
    term_echowarn "USB check has been disabled. Skipping."
    return 0
  fi
  _deviceType=$(devi_getDeviceType "$targetDevice")
  if [ "$_deviceType" != "usb" ]; then
    term_echoerr "The device you selected is not connected via USB (found TRAN: '$_deviceType') and the operation was therefore canceled."
    term_echowarn "Use $(term_boldify '--no-usb-check') to bypass this policy at your own risk."
    term_echoerr "Exiting..."
    exit 1
  fi
  term_echogood "The selected device '$targetDevice' is connected through USB."
}

asrt_checkImageSize() {
  local -r _deviceBlock=$1
  local -r _imageFile=$2
  if [ "$disableSizeCheck" == 'true' ]; then
    term_echowarn "Size check has been disabled. Skipping."
    return 0
  fi
  if [ "$(blockdev --getsz "$_imageFile")" -gt "$(blockdev --getsz "$_deviceBlock")" ]; then
    term_echoerr "The image is larger than the selected _deviceBlock '$_deviceBlock' and the operation was therefore canceled."
    term_echowarn "Use $(term_boldify '--no-size-check') to bypass this policy at your own risk."
    term_echoerr "Exiting..."
    exit 1
  fi
}

asrt_checkAction() {
  local -ra _actions=('help' 'version' 'format' 'install-image-copy' 'install-mount-rsync' 'list-usb-drives' 'inspect' 'probe')
  local -a _enabledActions=()
  local _act
  for _act in "${_actions[@]}"; do
    if [ "${userFlags[$_act]}" == 'true' ]; then
      _enabledActions+=("$_act")
    fi
  done
  if ((${#_enabledActions[@]} == 0)); then
    targetAction='install-auto'
  elif ((${#_enabledActions[@]} == 1)); then
    targetAction=${_enabledActions[0]}
  else
    prog_failAndExit "${prog_exitStatus[SYNOPSISNC]}" \
      "You cannot invoke multiple actions at once: $(prim_joinBy '+' "${_enabledActions[@]}")."
  fi
}

# $1: fsType
asrt_checkFSType() {
  local -r _fsType="$1"
  if ! prim_containsElement "$_fsType" "${prog_supportedFS[@]}"; then
    prog_failAndExit "${prog_exitStatus[SYNOPSISNC]}" "Filesystem type '$_fsType' not supported." \
      "Supported FS types: $(prim_joinBy "," "${prog_supportedFS[*]}")."
  fi
  if ! command -v "mkfs.$_fsType" &> /dev/null; then
    prog_failAndExit "${prog_exitStatus[MISDEP]}" \
      "Program 'mkfs.$_fsType' could not be found on your system." \
      "Please install it and retry."
  fi
}

asrt_checkUserVars() {
  # check partition types
  if [ -n "${userVars[fs]}" ]; then
    userVars[fs]=$(prim_normalizeFSType "${userVars[fs]}")
    asrt_checkFSType "${userVars[fs]}"
  fi
  if [ -n "${userVars['data-part-fs']}" ]; then
    userVars['data-part-fs']=$(prim_normalizeFSType "${userVars['data-part-fs']}")
    asrt_checkFSType "${userVars['data-part-fs']}"
  fi
  # check device
  if [ -n "${userVars[device]}" ]; then
    if [[ ! "${userVars[device]}" =~ '/dev/' ]] && [ -e "/dev/${userVars[device]}" ]; then
      userVars[device]="/dev/${userVars[device]}"
    fi
    asrt_checkDeviceIsOK "${userVars[device]}"
  fi
  if [ -n "${userVars['remote-bootloader']}" ] && [[ ! "${userVars['remote-bootloader']}" =~ ^[0-9]+\.[0-9]+$ ]]; then
    prog_failAndExit "${prog_exitStatus[SYNOPSISNC]}" \
      "Remote bootloader version '${userVars['remote-bootloader']}' set with $(term_boldify '--remote-bootloader') doesn't follow MAJOR.MINOR pattern." \
      "Valid examples are 4.10, 6.02"
  fi
  # Check dd-bs
  if [[ -n "${userVars['dd-bs']}" && ! ${userVars['dd-bs']} =~ ^[0-9]+[kMGT]?$ ]]; then
    prog_failAndExit "${prog_exitStatus[SYNOPSISNC]}" "$(term_boldify '--dd-bs') argument must be a valid block size quantifier, e.g. 512k, 2M."
  fi
}

asrt_checkUserFlags() {
  # Autoselect security
  if [ "${userFlags['autoselect']}" == 'true' ] && [ "${userFlags['no-usb-check']}" == 'true' ]; then
    prog_failAndExit "${prog_exitStatus[MISDEP]}" \
      "You cannot set $(term_boldify '-a, --autoselect') while disabling USB check with $(term_boldify '--no-usb-check')"
  fi
  if [ "${userFlags['no-hash-check']}" == 'true' ] && [ "${userFlags['force-hash-check']}" == 'true' ]; then
    prog_failAndExit "${prog_exitStatus[SYNOPSISNC]}" \
      "You cannot combine $(term_boldify '--no-hash-check') and $(term_boldify '--force-hash-check')"
  elif [ "${userFlags['no-hash-check']}" == 'true' ] && [ -n "${userVars['hash-file']}" ]; then
    prog_failAndExit "${prog_exitStatus[SYNOPSISNC]}" \
      "You cannot combine $(term_boldify '--no-hash-check') and $(term_boldify '--hash-file')"
  fi
  # warnings (only with sudo)
  if ((EUID == 0)); then
    # Eject format
    if [ "${userFlags['no-eject']}" == true ] && [ "$targetAction" == format ]; then
      term_echowarn "You don't need to prevent device ejection through $(term_boldify '-J') flag with 'format'."
    fi
    # Warn autoselecting while assume yes is false
    if [ "${userFlags['autoselect']}" == true ] && [ "${userFlags['assume-yes']}" == false ]; then
      term_echowarn "$(term_boldify '-a, --autoselect') is enabled by default when $(term_boldify '-y, --asume-yes') is not set."
    fi
    if [[ -n "${userVars['data-part-fs']}" && -z "${userFlags['data-part']}" ]]; then
      term_echowarn "You set $(term_boldify '--data-part-fs') option but forgot $(term_boldify -D). No data partition will be added."
    fi
  fi
}

asrt_checkFlagMatrix() {
  local _key
  for _key in "${!prog_userVarsCompatibilityMatrix[@]}"; do
    if [ ! -z "${userVars[$_key]}" ]; then
      #shellcheck disable=SC2086
      if ! prim_containsElement "$targetAction" ${prog_userVarsCompatibilityMatrix[$_key]}; then
        if [ "$_key" == "iso-file" ]; then
          prog_failAndExit "${prog_exitStatus[SYNOPSISNC]}" \
            "$(term_boldify $targetAction) doesn't require any positional arguments."
        else
          prog_failAndExit "${prog_exitStatus[SYNOPSISNC]}" \
            "$(term_boldify "$targetAction") targetAction doesn't support $(term_boldify --$_key) modifier."
        fi
      fi
    fi
  done
  for _key in "${!prog_userFlagsCompatibilityMatrix[@]}"; do
    if [ ! -z "${userFlags[$_key]}" ]; then
      #shellcheck disable=SC2086
      if ! prim_containsElement "$targetAction" ${prog_userFlagsCompatibilityMatrix[$_key]}; then
        prog_failAndExit "${prog_exitStatus[SYNOPSISNC]}" \
          "$(term_boldify $targetAction) targetAction doesn't support $(term_boldify --$_key) modifier."
      fi
    fi
  done
}

asrt_inspectImageBootCapabilities() {
  local _uefiCompatible=${isoInspections[supportsEFIBoot]}
  local _syslinuxCompatible=false
  if [ "${isoInspections[supportsEFIBoot]}" == true ]; then
    if [ "$targetFilesystem" != "vfat" ]; then
      term_echowarn "Found UEFI boot capabilities but you selected '$targetFilesystem' type, which is not compatible with UEFI boot." \
        "Be warned that only legacy boot might work, if any."
    else
      _uefiCompatible=true
      term_echogood "UEFI boot check validated. Your USB will work with UEFI boot."
    fi
  fi
  if [[ "$enforceGPT" == true && "${isoInspections[supportsEFIBoot]}" == false ]]; then
    term_echowarn "$(term_boldify '--gpt') option ignored because image file solely supports legacy BIOS boot, which requires MBR."
  fi
  if [ ! -z "${isoInspections[syslinuxConf]}" ]; then
    _syslinuxCompatible=true
    transientShouldInstallSyslinux=true
    if [ ! -z "${isoInspections[syslinuxVer]}" ]; then
      term_echogood "Found SYSLINUX config file and binary at version ${isoInspections[syslinuxVer]}."
    elif [ ! -z "${isoInspections[syslinuxBin]}" ]; then
      term_echogood "Found SYSLINUX config file and binary with unknown version."
    else
      term_echogood "Found SYSLINUX config file."
    fi
    term_echogood "A SYSLINUX booloader will be installed on your USB device."
  fi
  if [[ "$_syslinuxCompatible" == false && "$_uefiCompatible" == false ]]; then
    prog_failAndExit "${prog_exitStatus[MISBOOTCAP]}" \
      "The selected image is not hybrid, doesn't support UEFI or legacy booting with SYSLINUX." \
      "Therefore, it cannot result in any successful booting with $scriptName." \
      "Consider following the documentation provided with this image file."
  fi
}

asrt_checkSyslinuxInstall() {
  prog_checkPkg 'syslinux'
  if ! prog_hasPackage extlinux; then
    prog_failAndExit "${prog_exitStatus[MISDEP]}" \
      "Your distribution doesn't ship 'extlinux' with the 'syslinux' package." \
      "Please install 'extlinux' and try again."
  fi
  foundSyslinuxBiosFolder=$(find "$prog_syslinuxLibRoot" -type d -path '*/bios' -print -quit)
  foundSyslinuxMbrBinary=$(fs_findFileFromPatterns "$prog_syslinuxLibRoot" 'bios/mbr.bin' 'mbr.bin')
  if [ -z "$foundSyslinuxBiosFolder" ]; then
    prog_failAndExit "${prog_exitStatus[MISDEP]}" \
      "Could not find a SYSLINUX bios folder containing c32 bios module files on this system."
  fi
  if [ -z "$foundSyslinuxMbrBinary" ]; then
    prog_failAndExit "${prog_exitStatus[MISDEP]}" "Could not find a SYSLINUX MBR binary on this system."
  fi
}

# oo.ooooo.  oooo d8b  .ooooo.   .oooooooo
#  888' `88b `888""8P d88' `88b 888' `88b
#  888   888  888     888   888 888   888
#  888   888  888     888   888 `88bod8P'
#  888bod8P' d888b    `Y8bod8P' `8oooooo.
#  888                          d"     YD
# o888o                         "Y88888P'
#
# PROG MODULE
#
# This module exposes utilities related to
# program execution (arguments, process, dependencies...).
# Functions belonging to this module are prefixed with "prog_"

# $*: The message to print.
prog_failAndExit() {
  local -r _status=$1
  if ! [[ $_status =~ ^[0-9]+$ ]]; then
    term_echoerr "(prog_failAndExit) Internal state error."
    _status="${prog_exitStatus[INTERNALST]}"
  else
    shift
    if [ "$_status" -eq "${prog_exitStatus[SYNOPSISNC]}" ]; then
      [ $# -ne 0 ] && term_echoerr "$@"
      term_echoerr "Check $(term_boldify 'man 1 bootiso')."
    else
      term_echoerr "$@" "Exiting..."
    fi
  fi
  exit "$_status"
}

# $1: The name of the command to check against $PATH.
prog_hasPackage() {
  command -v "$1" &> /dev/null
  return $?
}

# $1: The name of the package command to check.
prog_checkPkg() {
  local -r _pkg=$1
  local _answer
  if ! prog_hasPackage "$_pkg"; then
    term_echowarn "Command '$_pkg' not found! Should be in package '${prog_commandPackages["$_pkg"]}'."
    if [ ! -z "$pkgmgr" ]; then
      read -r -n1 -p "${term_logPrefixEmpty}Attempt installation? (y/n)> " _answer
      echo
      case $_answer in
      y | Y)
        if ! $pkgmgr "${prog_commandPackages["$_pkg"]}"; then
          prog_failAndExit "${prog_exitStatus[MISDEP]}" "Installation of dependency '$_pkg' failed." \
            "Perhaps this dependency has a slightly different name on your distribution." \
            "Find it and install manually."
        else
          if ! prog_hasPackage "$_pkg"; then
            prog_failAndExit "${prog_exitStatus[MISDEP]}" "Program '$_pkg' is not accessible in the \$PATH environment even though the package ${prog_commandPackages["$_pkg"]} has just been installed."
          fi
        fi
        ;;
      *)
        prog_failAndExit "${prog_exitStatus[MISDEP]}" "Missing dependency '$_pkg'."
        ;;
      esac
    else
      prog_failAndExit "${prog_exitStatus[MISDEP]}" "Missing dependency '$_pkg'."
    fi
  fi
}

prog_cleanup() {
  local _asset
  _removeTempAsset() {
    if [[ "$1" =~ ^$prog_tempRoot ]] || [[ "$1" =~ ^$prog_mountRoot ]]; then
      if [ -d "$1" ]; then
        rm -rf "$1"
      elif [ -f "$1" ]; then
        rm "$1"
      else
        term_echowarn "Skipping deletion of unexpected asset type at '$1'."
      fi
    else
      term_echowarn "Skipping deletion of unexpected temporary asset at '$1'."
    fi
  }
  _ejectDevice() {
    if [[ "$completedAction" =~ ^install ]]; then
      if [[ "$noDeviceEjection" == false ]]; then
        if eject "$targetDevice" |& term_indentAll; then
          term_echogood "USB device succesfully ejected." \
            "You can safely remove it!"
        else
          term_echowarn "Failed to eject device '$targetDevice'."
        fi
      else
        term_echoinfo "USB device ejection skipped with $(term_boldify '-J, --no-eject')."
      fi
    fi
  }
  if ((EUID == 0)); then
    fs_umountElTorito
    fs_umountUSB
    for _asset in "${temporaryAssets[@]}"; do
      _removeTempAsset "$_asset"
    done
    _ejectDevice
  fi
}

prog_startTimer() {
  transientStartTime=$(date +%s)
}

#
#       .o8                         o8o
#      "888                         `"'
#  .oooo888   .ooooo.  oooo    ooo oooo
# d88' `888  d88' `88b  `88.  .8'  `888
# 888   888  888ooo888   `88..8'    888
# 888   888  888    .o    `888'     888
# `Y8bod88P" `Y8bod8P'     `8'     o888o
#
# DEVI MODULE
#
# Device and images operations.
# Functions belonging to this module are prefixed with "devi_"

devi_configureLabel() {
  local _user _vendor
  targetPartitionLabel=${targetPartitionLabel:-$(blkid -o value -s LABEL -- "$sourceImageFile")}
  case $targetFilesystem in
  vfat)
    # Label to uppercase, otherwise some DOS systems won't work properly
    targetPartitionLabel=${targetPartitionLabel^^}
    # FAT32 labels have maximum 11 chars
    targetPartitionLabel=${targetPartitionLabel:0:11}
    ;;
  exfat)
    # EXFAT labels have maximum 15 chars
    targetPartitionLabel=${targetPartitionLabel:0:15}
    ;;
  ntfs)
    # NTFS labels have maximum 32 chars
    targetPartitionLabel=${targetPartitionLabel:0:32}
    ;;
  ext2 | ext3 | ext4)
    # EXT labels have maximum 16 chars
    targetPartitionLabel=${targetPartitionLabel:0:16}
    ;;
  f2fs)
    # F2FS labels have maximum 512 glyphs
    # approximated with 512 chars
    targetPartitionLabel=${targetPartitionLabel:0:512}
    ;;
  *)
    term_echowarn "Unexpected partition type '$targetFilesystem'." "$prog_openTicketMessage"
    ;;
  esac
  # Fallback to "USER_VENDOR" if format
  if [[ "$targetAction" == format ]]; then
    _user=${SUDO_USER:-$USER}
    _vendor=$(lsblk -dno VENDOR "$targetDevice" 2> /dev/null)
    _vendor=${_vendor:-FLASH}
    targetPartitionLabel=${targetPartitionLabel:-"${_user^^}_${_vendor^^}"}
  else
    targetPartitionLabel=${targetPartitionLabel:-''}
  fi
  if [[ -z "${userVars['label']}" && -n "$targetPartitionLabel" ]]; then
    term_echogood "Partition label automatically set to '$targetPartitionLabel'." \
      "You can explicitly set the label with $(term_boldify '-L, --label')."
  elif [[ -n "$targetPartitionLabel" ]]; then
    term_echogood "Partition label manually set to '$targetPartitionLabel'."
  fi

}

# $1 : a device block
# Returns "usb" if device is USB, "ata" for SATA and "other" otherwise
devi_getDeviceType() {
  local -r _deviceBlock=$1
  local _deviceType
  _deviceType=$(lsblk --nodeps -nlo TRAN "$_deviceBlock")
  echo "${_deviceType:-other}"
}

devi_deviceIsDisk() {
  local -r _deviceBlock="$1"
  lsblk --nodeps -no TYPE "$_deviceBlock"
  return $?
}

devi_selectDevice() {
  local _selectedDevice
  _chooseDevice() {
    term_echoinfo "Select the device corresponding to the USB device you want to make bootable: $(prim_joinBy ',' "${devicesList[@]}")" \
      "\n${term_logPrefixEmpty}Type CTRL+D to quit."
    read -r -p "${term_logPrefixEmpty}Select device id> " _selectedDevice
    echo
    if prim_containsElement "$_selectedDevice" "${devicesList[@]}"; then
      targetDevice="/dev/$_selectedDevice"
    else
      if prim_containsElement "$_selectedDevice" "" "exit"; then
        term_echoinfo "Exiting on user request."
        exit 0
      else
        prog_failAndExit "${prog_exitStatus[MISDEV]}" "The drive $_selectedDevice does not exist."
      fi
    fi
  }
  _handleDeviceSelection() {
    local _selectedDeviceBlock
    if [ ${#devicesList[@]} -eq 1 ] && [ "$disableUSBCheck" == false ]; then
      # autoselect
      if [ "$disableConfirmation" == false ] || {
        [ "$disableConfirmation" == 'true' ] && [ "$autoselect" == 'true' ]
      }; then
        _selectedDeviceBlock="${devicesList[0]}"
        term_echogood "Autoselecting '$_selectedDeviceBlock' (only USB device candidate)"
        targetDevice="/dev/$_selectedDeviceBlock"
      else
        _chooseDevice
      fi
    else
      _chooseDevice
    fi
  }
  if [ -z "$targetDevice" ]; then
    # List all hard disk drives
    if exec_listUSBDrives; then
      _handleDeviceSelection
    else
      prog_failAndExit "${prog_exitStatus[NODEV]}"
    fi
  fi
  targetPartition="${targetDevice}1"
}

# Return status is
# 0: OK
# 1: failed appending partition table
# 2: failed formating partition
devi_addDataPartition() {
  local _dataPartition _diskReport _sectorSize _partSize _humanSize _partScheme _partType
  _diskReport=$(sfdisk -lJ "$targetDevice")
  _partScheme=$(echo "$_diskReport" | jq -r '.partitiontable.label')
  _partType=$(fs_inferFSType "$_partScheme" "$dataPartFstype")
  sfdisk --append "$targetDevice" < <(echo "-,-,$_partType") || return 1
  _diskReport=$(sfdisk -lJ "$targetDevice")
  _dataPartition=$(echo "$_diskReport" | jq -r '.partitiontable.partitions[-1].node')
  fs_formatPartition "$dataPartFstype" "$_dataPartition" "DATA" || return 2
  _sectorSize=$(echo "$_diskReport" | jq -r '.partitiontable.sectorsize')
  _partSize=$(echo "$_diskReport" | jq -r '.partitiontable.partitions[-1].size')
  _humanSize=$(numfmt --to=iec-i --suffix=B $((_sectorSize * _partSize)))
  term_echogood "Created $dataPartFstype data partition $_dataPartition of size $_humanSize"
}

# $1: partScheme - MBR or GPT
# $2: notBootable - true or false
devi_createPartitionTable() {
  local -r _partScheme=$1
  local -r _notBootable=$2
  local _partitionOptions
  local _sfdiskCommand='sfdisk'
  local _sfdiskVersion
  _sfdiskVersion=$(sfdisk -v | grep -Po '\d+\.\d+')
  _makeSfdiskCommand() {
    # Retrocompatibility for 'old' sfdisk versions
    if prim_compute "$_sfdiskVersion >= 2.28"; then
      _sfdiskCommand='sfdisk -W always'
    fi
  }
  _initGPT() {
    local _partitionType=${targetPartitionScheme:-$(fs_inferFSType gpt "$targetFilesystem")}
    _partitionOptions="label: gpt\n"
    if [ "$_notBootable" == false ]; then
      # Windows UEFI boot partitions must be of type "Windows Data Partition",
      # otherwise bug with "Drivers not found"
      if [[ "${isoInspections[supportsEFIBoot]}" == true && "${isoInspections[hasWimFile]}" == false ]]; then
        # Set typecode to EFI System Partition
        _partitionType="${fs_gptPartitionCodes[efi]}"
      else
        prog_failAndExit "${prog_exitStatus[INTERNALST]}" "GPT partition tables are not compatible with legacy BIOS boot."
      fi
    fi
    _partitionOptions+="type=${_partitionType}"
  }
  _initMBR() {
    local _partitionType=${targetPartitionScheme:-$(fs_inferFSType mbr "$targetFilesystem")}
    _partitionOptions="label: dos\n"
    _partitionOptions+="$targetPartition : start=2048, type=$_partitionType"
  }
  _makeSfdiskCommand
  case "$_partScheme" in
  GPT) _initGPT ;;
  MBR) _initMBR ;;
  *) prog_failAndExit "${prog_exitStatus[INTERNALST]}" "Unexpected partition scheme '$1'" ;;
  esac
  if [[ "$_notBootable" == false && "$_partScheme" == MBR ]]; then
    _partitionOptions+=", bootable"
  fi
  term_echogood "Creating $_partScheme partition table with 'sfdisk' v$_sfdiskVersion..."
  echo -e "$_partitionOptions" | $_sfdiskCommand "$targetDevice" |& term_indentAll || prog_failAndExit "${prog_exitStatus[INTERNALIO]}" \
    "Failed to write USB device $_partScheme partition table."
  partx -u "$targetDevice" # Refresh partition table
  fs_syncdev
}

# $1: notBootable - true or false, default false
devi_partitionUSB() {
  local -r _notBootable=${1:-false}
  local _partScheme
  _shouldWipeUSBKey() {
    local _answer='y'
    term_echowarn "About to wipe the content of device '$targetDevice'."
    if [ "$disableConfirmation" == false ]; then
      read -r -p "${term_logPrefixEmpty}Are you sure you want to proceed? (y/n)> " _answer
    else
      term_echowarn "Bypassing confirmation with $(term_boldify '-y, --assume-yes')."
    fi
    if [ "$_answer" == 'y' ]; then
      return 0
    else
      return 1
    fi
  }
  _unmountPartitions() {
    local _partition
    # unmount any partition on selected device
    mapfile -t devicePartitions < <(grep -oP "^\\K$targetDevice\\S*" /proc/mounts)
    for _partition in "${devicePartitions[@]}"; do
      if ! umount "$_partition" > /dev/null; then
        prog_failAndExit "${prog_exitStatus[INTERNALIO]}" \
          "Failed to unmount $_partition. It's likely that the partition is busy."
      fi
    done
  }
  _eraseDevice() {
    term_echoinfo "Erasing contents of '$targetDevice'..."
    # clean signature from selected device
    wipefs --all --force "$targetDevice" &> /dev/null
    # erase drive
    dd if=/dev/zero of="$targetDevice" bs=512 count=1 conv=notrunc status=none |&
      term_indentAll ||
      prog_failAndExit "${prog_exitStatus[INTERNALIO]}" "Failed to erase USB device." \
        "It's likely that the device has been ejected and needs to be reconnected." \
        "You can check the availability of USB drives with $(term_boldify "$scriptName -l")."
    fs_syncdev
  }

  if _shouldWipeUSBKey; then
    _unmountPartitions
    _eraseDevice
    if [ "$shouldMakePartition" == 'true' ]; then
      if [[ "$enforceGPT" == true && (${isoInspections[supportsEFIBoot]} == true || "$_notBootable" == true) ]]; then
        _partScheme=GPT
      else
        _partScheme=MBR
      fi
      devi_createPartitionTable $_partScheme "$_notBootable"
      fs_formatPartition "$targetFilesystem" "$targetPartition" "$targetPartitionLabel"
    fi
  else
    prog_failAndExit "${prog_exitStatus[USERABORT]}" "Canceling operation."
  fi
}

devi_installSyslinuxVersion() {
  local -r _desiredSyslinuxVersion=$1
  local _versions
  local _minor
  local _filename
  local _kernelOrgURL="https://mirrors.edge.kernel.org/pub/linux/utils/boot/syslinux/Testing"
  local _syslinuxArchive
  local _assetURL
  local _status
  local _abortingMessage="Aborting SYSLINUX installation and resuming with local install."
  _checkConnexion() {
    _status=$(curl -sLIo /dev/null -w "%{http_code}" "$_kernelOrgURL")
    if [ "$_status" != 200 ]; then
      if [ "$_status" == 000 ]; then
        prog_failAndExit "${prog_exitStatus[HOSTUNR]}" "kernel.org is unreachable. You don't seem to have an internet connection." \
          "Please try again later or use $(term_boldify '--local-bootloader') to force usage of the local SYSLINUX version."
        return 9
      else
        term_echowarn "Couldn't GET $_kernelOrgURL." \
          "Received status code '$_status'." \
          "$prog_openTicketMessage" \
          "$_abortingMessage"
        return 10
      fi
    fi
    return 0
  }
  _findMinorVersions() {
    _versions="$(curl -sL "$_kernelOrgURL" | grep -oP 'href="\K\d+\.\d+(?=/")' | sort --version-sort)"
    if (($? != 0)); then
      term_echowarn "Couldn't GET $_kernelOrgURL." \
        "Aborting syslinux installation and resuming with local install."
      return 10
    elif [ -z "$_versions" ]; then
      term_echoerr "Couldn't parse the result of $_kernelOrgURL." \
        "This is not expected: please open a ticket at $prog_ticketsurl." \
        "$_abortingMessage"
      return 11
    fi
    _minor=$(echo "$_versions" | grep -E "^$_desiredSyslinuxVersion" | grep "^${_desiredSyslinuxVersion%.}" | tail -n 1)
    if [ -z "$_minor" ]; then
      term_echoerr "Version '$_desiredSyslinuxVersion' is not available at kernel.org."
      return 8
    fi
    return 0
  }
  _findMatchedRelease() {
    _filename=$(curl -sL "$_kernelOrgURL/$_minor/" | grep -oP 'href="\Ksyslinux-\d+\.\d+-\w+\d+\.tar\.gz(?=")' | sort --version-sort | tail -n1)
    if [ -z "$_filename" ]; then
      term_echoerr "Couldn't find '$_filename'."
      return 11
    fi
    _assetURL="$_kernelOrgURL/$_minor/$_filename"
    _syslinuxArchive=$prog_cacheRoot/$_filename
    return 0
  }
  _downloadMatchedVersion() {
    if [ -e "$_syslinuxArchive" ]; then
      term_echogood "Found '$_syslinuxArchive' in cache."
      return 0
    fi
    if curl -sL -o "$_syslinuxArchive" "$_assetURL"; then
      if [ -f "$_syslinuxArchive" ]; then
        term_echogood "Download of '$_syslinuxArchive' completed ($(du -h "$_syslinuxArchive" | awk '{print $1}'))"
      else
        term_echowarn "Missing file '$_syslinuxArchive'." \
          "This is not expected: please open a ticket at $prog_ticketsurl." \
          "$_abortingMessage"
        return 10
      fi
    else
      term_echowarn "Couldn't get '$_assetURL'." \
        "This is not expected: please open a ticket at $prog_ticketsurl." \
        "$_abortingMessage"
      return 10
    fi
    return 0
  }
  _extractMatchedVersion() {
    if tar -xf "$_syslinuxArchive" -C "$prog_tempRoot"; then
      syslinuxInstallDir="$prog_tempRoot/$(basename "${_syslinuxArchive%.tar.gz}")"
      temporaryAssets+=("$syslinuxInstallDir")
    else
      rm "$_syslinuxArchive"
      return 11
    fi
  }
  _configureSyslinuxInstall() {
    local _extlinuxBin
    local _mbrBin
    _extlinuxBin=$(fs_findFileFromPatterns "$syslinuxInstallDir" 'bios/extlinux/extlinux' 'extlinux/extlinux' 'extlinux')
    _mbrBin=$(fs_findFileFromPatterns "$syslinuxInstallDir" 'bios/mbr/mbr.bin' 'mbr/mbr.bin' 'mbr.bin')
    if [ -z "$_extlinuxBin" ]; then
      term_echowarn "Couldn't find 'extlinux' binary in installation folder." \
        "$_abortingMessage"
      return 10
    fi
    if [ -z "$_mbrBin" ]; then
      term_echowarn "Couldn't find 'mbr.bin' in installation folder." \
        "$_abortingMessage"
      return 10
    fi
    syslinuxInstall['mbrBin']="$_mbrBin"
    syslinuxInstall['extBin']="$_extlinuxBin"
    return 0
  }
  prog_checkPkg 'curl'
  _inferSyslinuxVersion
  _checkConnexion || return "$?"
  _findMinorVersions || return "$?"
  _findMatchedRelease || return "$?"
  _downloadMatchedVersion || return "$?"
  _extractMatchedVersion || return "$?"
  _configureSyslinuxInstall || return "$?"
  term_echogood "SYSLINUX version '$_minor' temporarily set for installation."
}

# $1: mountPoint
# $2: inspect syslinux? true or false
devi_inspectPartition() {
  local -r _mountPoint="$1"
  local -r _shouldInspectSyslinux=$2
  local _supportsEFIBoot _hasWimFile _syslinuxBin _syslinuxConf _syslinuxVer
  _supportsEFIBoot=${isoInspections[supportsEFIBoot]:-false}
  _hasWimFile=${isoInspections[hasWimFile]:-false}
  _syslinuxBin=${isoInspections[syslinuxBin]}
  _syslinuxConf=${isoInspections[syslinuxConf]}
  _syslinuxVer=${isoInspections[syslinuxVer]}
  local -a _sysLinuxLocations=('boot/syslinux/syslinux.cfg' 'syslinux/syslinux.cfg' 'syslinux.cfg' 'boot/syslinux/extlinux.conf'
    'boot/syslinux/extlinux.cfg' 'boot/extlinux/extlinux.conf' 'boot/extlinux/extlinux.cfg' 'syslinux/extlinux.conf'
    'syslinux/extlinux.cfg' 'extlinux/extlinux.conf' 'extlinux/extlinux.cfg' 'extlinux.conf' 'extlinux.cfg')
  local -a _isoLinuxLocations=('boot/isolinux/isolinux.cfg' 'isolinux/isolinux.cfg' 'isolinux.cfg' 'boot/syslinux/isolinux.cfg' 'syslinux/isolinux.cfg')
  _inspectSyslinux() {
    _syslinuxBin=$(fs_matchFirstExpression "$_mountPoint" 'syslinux.bin' 'isolinux.bin' 'extlinux.bin' 'boot.bin' 'extlinux' 'syslinux' 'isolinux')
    if [ ! -z "$_syslinuxBin" ]; then
      _syslinuxVer=$(strings "$_syslinuxBin" | grep -E 'ISOLINUX|SYSLINUX|EXTLINUX' | grep -oP '(\d+\.\d+)' | awk 'NR==1{print $1}')
    fi
    _syslinuxConf=$(fs_findFileFromPatterns "$_mountPoint" "${_sysLinuxLocations[@]}")
    if [ -z "$_syslinuxConf" ]; then
      _syslinuxConf=$(fs_matchFirstExpression "$_mountPoint" 'syslinux.cfg' 'extlinux.conf' 'extlinux.cfg')
    fi
    if [ -z "$_syslinuxConf" ]; then
      _syslinuxConf=$(fs_findFileFromPatterns "$_mountPoint" "${_isoLinuxLocations[@]}")
      _syslinuxConf=${_syslinuxConf:-$(fs_firstMatchInFolder "$_mountPoint" 'isolinux.cfg')}
    fi
  }
  _inspectEFICapabilities() {
    local _hasEfiRoot
    local _hasEfiFile
    _hasEfiRoot=$(find "$_mountPoint" -type d -iname 'efi' -print -quit)
    _hasEfiFile=$(find "$_mountPoint" -type f -ipath '*/efi/*.efi' -prune -print -quit)
    if [ ! -z "$_hasEfiFile" ] && [ ! -z "$_hasEfiRoot" ]; then
      _supportsEFIBoot=true
    fi
  }
  _inspectWindows() {
    if [[ -e "$_mountPoint/sources/install.wim" ]]; then
      _hasWimFile=true
    fi
  }
  _inspectEFICapabilities
  _inspectWindows
  isoInspections[supportsEFIBoot]=$_supportsEFIBoot
  isoInspections[hasWimFile]=$_hasWimFile
  if [[ $_shouldInspectSyslinux == true ]]; then
    _inspectSyslinux
    isoInspections[syslinuxConf]="${_syslinuxConf#$_mountPoint}"
    isoInspections[syslinuxBin]="${_syslinuxBin#$_mountPoint}"
    isoInspections[syslinuxVer]="$_syslinuxVer"
  fi
}

devi_inspectHybridImage() {
  local _diskReport _partScheme
  local _supportsEFIBoot _supportsBIOSBoot
  _inspectMBRPartTable() {
    local _startSector
    # Look for the first ESP partition
    _startSector=$(echo "$_diskReport" | jq ".partitiontable.partitions | map(select(.type==\"${fs_mbrPartitionCodes[efi]}\"))[0].start | select (.!=null)")
    # If ESP found, look for first bootable
    if [[ -n "$_startSector" ]]; then
      _supportsEFIBoot=true
    else
      _supportsEFIBoot=false
    fi
    _startSector=$(echo "$_diskReport" | jq '.partitiontable.partitions | map(select(.bootable==true))[0].start | select (.!=null)')
    if [[ -n "$_startSector" ]]; then
      _supportsBIOSBoot=true
    else
      _supportsBIOSBoot=false
    fi
  }
  _inspectGPTPartTable() {
    local _startSector
    # In GPT mode, UEFI is theoretically the only possible boot mode
    _startSector=$(echo "$_diskReport" | jq ".partitiontable.partitions | map(select(.type==\"${fs_gptPartitionCodes[efi]}\"))[0].start | select (.!=null)")
    _supportsBIOSBoot=false
    if [[ -n "$_startSector" ]]; then
      _supportsEFIBoot=true
    else
      _supportsEFIBoot=false
    fi
  }
  _diskReport=$(sfdisk -lJ -- "$sourceImageFile" 2> /dev/null)
  if (($? != 0)); then
    prog_failAndExit "${prog_exitStatus[INTERNALIO]}" "sfdisk couldn't read the partition table on the image file, which is likely corrupted."
  fi
  _partScheme=$(echo "$_diskReport" | jq -r '.partitiontable.label')
  case $_partScheme in
  dos) _inspectMBRPartTable ;;
  gpt) _inspectGPTPartTable ;;
  esac
  isoInspections[supportsBIOSBoot]="$_supportsBIOSBoot"
  isoInspections[supportsEFIBoot]="$_supportsEFIBoot"
}

devi_inspectElToritoImage() {
  local _mountPoint
  _mountPoint=$(fs_createMountFolder iso) || exit "$?"
  fs_mountElToritoFile "$_mountPoint"
  devi_inspectPartition "$_mountPoint" true
  fs_umountPartition "$_mountPoint"
}

#              .
#            .o8
#  .oooo.o .o888oo  .ooooo.  oo.ooooo.
# d88(  "8   888   d88' `88b  888' `88b
# `"Y88b.    888   888ooo888  888   888
# o.  )88b   888 . 888    .o  888   888
# 8""888P'   "888" `Y8bod8P'  888bod8P'
#                             888
#                            o888o
#
# STEP MODULE
#
# Execution program steps.
# The functions exposed in this module are high-level semantic
# units of the whole program execution.
# Functions belonging to this module are prefixed with "step_"

step_initDevicesList() {
  local -a _devices
  local _device
  mapfile -t _devices < <(lsblk -dno NAME)
  devicesList=()
  for _device in "${_devices[@]}"; do
    if [ "$(devi_getDeviceType "/dev/$_device")" == "usb" ] || [ "$disableUSBCheck" == 'true' ]; then
      devicesList+=("$_device")
    fi
  done
}

step_inspectImageFile() {
  local _isHybrid
  _inspectImageFilesystem() {
    file -b -- "$sourceImageFile" | grep -q '^ISO 9660 CD-ROM filesystem'
    if (($? == 0)); then
      _isHybrid=false
    else
      _isHybrid=true
    fi
  }
  _inspectImageFilesystem
  if [[ $_isHybrid == true ]]; then
    devi_inspectHybridImage
  else
    devi_inspectElToritoImage
  fi
  isoInspections[isHybrid]=$_isHybrid
}

step_installBootloader() {
  local _syslinuxFolder
  local _syslinuxConfig
  local _localSyslinuxVersion
  _inferSyslinuxVersion() {
    _localSyslinuxVersion=$(syslinux --version |& grep -oP '(\d+\.\d+)')
    if [ "$targetBootloaderVersion" != 'auto' ]; then
      syslinuxVersion="$targetBootloaderVersion"
    else
      syslinuxVersion=${isoInspections[syslinuxVer]:-"$_localSyslinuxVersion"}
    fi
  }
  # return 0 : install from kernel.org
  # return 1+: install from local
  _checkSyslinuxVersion() {
    local -i _versionsMatch=0
    if [ "$localBootloader" == true ]; then
      term_echogood "Enfoced local SYSLINUX bootloader at version '$_localSyslinuxVersion'."
      return 1
    fi
    if [ -z "$syslinuxVersion" ]; then
      return 1
    fi
    if [ "$targetBootloaderVersion" != 'auto' ]; then
      term_echoinfo "Searching for SYSLINUX V$syslinuxVersion remotely."
      if ! devi_installSyslinuxVersion "$syslinuxVersion"; then
        if [ ! -z "${isoInspections[syslinuxVer]}" ]; then
          term_echowarn "Falling back to image SYSLINUX version '${isoInspections[syslinuxVer]}'"
          syslinuxVersion="${isoInspections[syslinuxVer]}"
          devi_installSyslinuxVersion "${isoInspections[syslinuxVer]}"
          return $?
        else
          return 1
        fi
      else
        return 0
      fi
    fi
    term_echoinfo "Found local SYSLINUX version '$_localSyslinuxVersion'"
    prim_compute "$_localSyslinuxVersion == ${isoInspections[syslinuxVer]}" > /dev/null
    _versionsMatch=$?
    if ((_versionsMatch == 0)); then
      term_echogood "image SYSLINUX version matches local version."
      return 1
    else
      term_echowarn "image SYSLINUX version doesn't match local version." \
        "Scheduling download of version $syslinuxVersion..."
      if ! devi_installSyslinuxVersion "$syslinuxVersion"; then
        term_echowarn "Falling back to local SYSLINUX version '$_localSyslinuxVersion'."
        syslinuxVersion="$_localSyslinuxVersion"
        return 1
      fi
    fi
  }
  _setSyslinuxLocation() {
    local _isoFolder
    local _isolinuxConfig
    if [[ "${isoInspections[syslinuxConf]}" =~ isolinux.cfg ]]; then
      _isolinuxConfig="$transientUsbMountPoint${isoInspections[syslinuxConf]}"
      _isoFolder=$(dirname "$_isolinuxConfig")
      _syslinuxConfig="$_isoFolder/syslinux.cfg"
      mv "$_isolinuxConfig" "$_syslinuxConfig"
      term_echoinfo "Found ISOLINUX config file at '$_isolinuxConfig'." \
        "Moving to '$_syslinuxConfig'."
    else
      _syslinuxConfig="$transientUsbMountPoint${isoInspections[syslinuxConf]}"
    fi
    _syslinuxFolder=$(dirname "$_syslinuxConfig")
  }
  _installWtLocalExtlinux() {
    syslinuxInstall=(['mbrBin']="$foundSyslinuxMbrBinary" ['extBin']='extlinux')
    syslinuxVersion="$_localSyslinuxVersion"
    term_echoinfo "Installing SYSLINUX bootloader in '$_syslinuxFolder' with local version '$syslinuxVersion'..."
    rsync --no-links --no-perms --no-owner --no-group -I "$foundSyslinuxBiosFolder"/*.c32 "$_syslinuxFolder" |&
      term_indentAll ||
      term_echowarn "SYSLINUX could not install C32 BIOS modules."
    fs_syncdev
    term_echogood "C32 BIOS modules successfully installed."
    ${syslinuxInstall['extBin']} --stupid --install "$_syslinuxFolder" |& term_indentAll || prog_failAndExit "${prog_exitStatus[INTERNALTP]}" \
      "SYSLINUX bootloader could not be installed."
    fs_syncdev
  }
  _installWtKernelOrgExtlinux() {
    term_echoinfo "Installing SYSLINUX bootloader in '$_syslinuxFolder' with kernel.org version '$syslinuxVersion'..."
    if ! ${syslinuxInstall['extBin']} --stupid --install "$_syslinuxFolder" |& term_indentAll; then
      term_echowarn "Could not run SYSLINUX '$syslinuxVersion' from kernel.org." \
        "Attempting with local SYSLINUX install..."
      _installWtLocalExtlinux > /dev/null
    fi
    fs_syncdev
  }
  _installMasterBootRecordProg() {
    dd bs=440 count=1 conv=notrunc status=none if="${syslinuxInstall['mbrBin']}" of="$targetDevice" |&
      term_indentAll ||
      prog_failAndExit "${prog_exitStatus[INTERNALIO]}" "Failed to install Master Boot Record program."
    fs_syncdev
    term_echogood "Succesfully installed Master Boot Record program."
  }
  _inferSyslinuxVersion
  _setSyslinuxLocation
  _checkSyslinuxVersion
  case $? in
  0) _installWtKernelOrgExtlinux ;;
  *) _installWtLocalExtlinux ;;
  esac
  term_echogood "Successfully installed SYSLINUX bootloader at version '$syslinuxVersion'."
  _installMasterBootRecordProg
}

step_copyWithRsync() {
  _rsyncWithProgress() {
    # _i must be defined for term_updateProgress
    local -i _i=1
    local _statusFile
    local _wimFile="$transientElToritoMountPoint/sources/install.wim"
    local _rsyncOptions=""
    local _status
    _statusFile=$(fs_createTempFile "bootiso-rsync-status")
    temporaryAssets+=("$_statusFile")
    if [ -f "$_wimFile" ]; then
      if [ "$disableWimsplit" == false ]; then
        _rsyncOptions="--exclude sources/install.wim"
        term_echogood "Detected a Windows install.wim file, which will be handled by 'wimlib-imagex' utility."
      else
        term_echowarn "Detected a Windows install.wim file but wimsplit has been disabled with $(term_boldify '--no-wim-split') option."
      fi
    fi
    ( 
      # shellcheck disable=SC2086
      rsync -r -q -I --no-links --no-perms --no-owner --no-group $_rsyncOptions "$transientElToritoMountPoint"/. "$transientUsbMountPoint"
      _status=$?
      term_cleanProgress
      if ((_status == 0)) && [ -f "$_wimFile" ] && [ "$disableWimsplit" == false ]; then
        echo
        wimlib-imagex split "$_wimFile" "$transientUsbMountPoint/sources/install.swm" 1024 |& term_indentAll
      fi
      echo "$_status" > "$_statusFile"
    ) &
    pid=$!
    echo -n "$scriptName: Copying files from image to USB device with 'rsync'    "
    while [ -e "/proc/$pid" ]; do
      term_updateProgress
    done
    term_cleanProgress
    _status=$(cat "$_statusFile")
    if [ ! "$_status" -eq 0 ]; then
      prog_failAndExit "${prog_exitStatus[INTERNALIO]}" "Copy command with 'rsync' failed."
    fi
  }
  prog_checkPkg 'rsync'
  _rsyncWithProgress
  fs_syncWithProgress
}

step_copyWithDD() {
  _ddWithProgress() {
    local -i _i=1
    local _statusFile
    local _status
    _statusFile=$(fs_createTempFile "bootiso-status")
    temporaryAssets+=("$_statusFile")
    ( 
      dd if="$sourceImageFile" of="$targetDevice" bs="$ddBusSize" status=none
      echo "$?" > "$_statusFile"
    ) &
    pid=$!
    echo -n "$scriptName: Copying files from image to USB device with 'dd'    "
    while [ -e "/proc/$pid" ]; do
      term_updateProgress
    done
    term_cleanProgress
    _status=$(cat "$_statusFile")
    if [ ! "$_status" -eq 0 ]; then
      prog_failAndExit "${prog_exitStatus[INTERNALIO]}" "Copy command with 'dd' failed."
    fi
  }
  _ddWithProgress
  fs_syncWithProgress
}

step_initPckgManager() {
  if prog_hasPackage apt-get; then # Debian
    pkgmgr="apt-get install"
    return 0
  fi
  if prog_hasPackage dnf; then # Fedora
    pkgmgr="dnf install"
    return 0
  fi
  if prog_hasPackage yum; then # Fedora
    pkgmgr="yum install"
    return 0
  fi
  if prog_hasPackage pacman; then # Arch
    pkgmgr="pacman -S"
    return 0
  fi
  if prog_hasPackage zypper; then # OpenSuse
    pkgmgr="zypper install"
    return 0
  fi
  if prog_hasPackage emerge; then # Gentoo
    pkgmgr="emerge"
    return 0
  fi
  if prog_hasPackage xbps-install; then # Void
    pkgmgr="xbps-install"
    return 0
  fi
  if prog_hasPackage eopkg; then # Solus
    pkgmgr="eopkg install"
    return 0
  fi
  return 1
}

step_parseArguments() {
  local _key
  local _isEndOfOptions=false
  local _wrongOptions
  local _options
  local -a _extractedOptions
  _enableUserFlag() {
    userFlags["$1"]=true
  }
  _setUserVar() {
    userVars["$1"]=$2
  }
  while [[ $# -gt 0 ]]; do
    _key="$1"
    if [ "$_isEndOfOptions" == false ]; then
      case $_key in
      # ACTIONS
      -h | --help | help)
        _enableUserFlag 'help'
        shift
        ;;
      -v | --version)
        _enableUserFlag 'version'
        shift
        ;;
      -l | --list-usb-drives)
        _enableUserFlag 'list-usb-drives'
        shift
        ;;
      -p | --probe)
        _enableUserFlag 'probe'
        shift
        ;;
      -f | --format)
        _enableUserFlag 'format'
        shift
        ;;
      -i | --inspect)
        _enableUserFlag 'inspect'
        shift
        ;;
      --dd | --icopy)
        _enableUserFlag 'install-image-copy'
        shift
        ;;
      --mrsync)
        _enableUserFlag 'install-mount-rsync'
        shift
        ;;
      # OPTIONS
      --dd-bs)
        if (($# < 2)); then
          prog_failAndExit "${prog_exitStatus[SYNOPSISNC]}" \
            "Missing value for '$1' flag. Please provide a number of bytes, see dd(1)."
        fi
        _setUserVar 'dd-bs' "$2"
        shift 2
        ;;
      -D | --data-part)
        _enableUserFlag 'data-part'
        shift
        ;;
      --local-bootloader)
        _enableUserFlag 'local-bootloader'
        shift
        ;;
      --remote-bootloader)
        if (($# < 2)); then
          prog_failAndExit "${prog_exitStatus[SYNOPSISNC]}" \
            "Missing value for '$1' flag. Please provide a version following MAJOR.MINOR pattern. ex: '4.10'."
        fi
        _setUserVar 'remote-bootloader' "$2"
        shift 2
        ;;
      --gpt)
        _enableUserFlag 'gpt'
        shift
        ;;
      -y | --assume-yes)
        _enableUserFlag 'assume-yes'
        shift
        ;;
      -d | --device)
        if (($# < 2)); then
          prog_failAndExit "${prog_exitStatus[SYNOPSISNC]}" "Missing value for '$1' flag. Please provide a device."
        fi
        _setUserVar 'device' "$2"
        shift 2
        ;;
      --part-type)
        if (($# < 2)); then
          prog_failAndExit "${prog_exitStatus[SYNOPSISNC]}" "Missing value for '$1' flag. Please provide a partition type."
        fi
        _setUserVar 'part-type' "${2}"
        shift 2
        ;;
      -t | --type | -F | --fs)
        if (($# < 2)); then
          prog_failAndExit "${prog_exitStatus[SYNOPSISNC]}" "Missing value for '$1' flag. Please provide a filesystem type."
        fi
        _setUserVar 'fs' "${2,,}" #lowercased
        shift 2
        ;;
      --data-part-fs)
        if (($# < 2)); then
          prog_failAndExit "${prog_exitStatus[SYNOPSISNC]}" "Missing value for '$1' flag. Please provide a filesystem type."
        fi
        _setUserVar 'data-part-fs' "${2,,}" #lowercased
        shift 2
        ;;
      -L | --label)
        if (($# < 2)); then
          prog_failAndExit "${prog_exitStatus[SYNOPSISNC]}" "Missing value for '$1' flag. Please provide a label."
        fi
        _setUserVar 'label' "$2"
        shift 2
        ;;
      --hash-file)
        if (($# < 2)); then
          prog_failAndExit "${prog_exitStatus[SYNOPSISNC]}" "Missing value for '$1' flag. Please provide a hash file."
        fi
        _setUserVar 'hash-file' "$2"
        shift 2
        ;;
      -J | --no-eject)
        _enableUserFlag 'no-eject'
        shift
        ;;
      -H | --no-hash-check)
        _enableUserFlag 'no-hash-check'
        shift
        ;;
      -a | --autoselect)
        _enableUserFlag 'autoselect'
        shift
        ;;
      -M | --no-mime-check)
        _enableUserFlag 'no-mime-check'
        shift
        ;;
      --no-usb-check)
        _enableUserFlag 'no-usb-check'
        shift
        ;;
      --no-size-check)
        _enableUserFlag 'no-size-check'
        shift
        ;;
      --force-hash-check)
        _enableUserFlag 'force-hash-check'
        shift
        ;;
      --no-wimsplit)
        _enableUserFlag 'no-wimsplit'
        shift
        ;;
      --)
        _isEndOfOptions=true
        shift
        ;;
      -*)
        if [[ "$_isEndOfOptions" == false ]]; then
          if [[ "$_key" =~ ^-- ]]; then
            prog_failAndExit "${prog_exitStatus[SYNOPSISNC]}" "Unknown option: $(term_boldify "$_key")."
          # Handle stacked options
          elif [[ "$_key" =~ ^-["$prog_shortOptions"]{2,}$ ]]; then
            shift
            _options=${_key#*-}
            mapfile -t _extractedOptions < <(echo "$_options" | grep -o . | xargs -d '\n' -n1 printf '-%s\n')
            set -- "${_extractedOptions[@]}" "$@"
          else
            printf "\\e[0;31m%s\\e[m" "$scriptName: Unknown options: "
            printf '%s.' "$_key" | GREP_COLORS='mt=00;32:sl=00;31' grep --color=always -P "[$prog_shortOptions]"
            if [[ "$_key" =~ ^-[a-zA-Z0-9]+$ ]]; then
              _wrongOptions=$(printf '%s' "${_key#*-}" | grep -Po "[^$prog_shortOptions]" | tr -d '\n')
              if [ ${#_key} -eq 2 ]; then
                term_echowarn "$(term_boldify "$_wrongOptions") flag were not recognized."
              else
                term_echowarn "$(term_boldify "$_wrongOptions") flags were not recognized."
              fi
            fi
            prog_failAndExit "${prog_exitStatus[SYNOPSISNC]}"
          fi
        else
          _setUserVar 'iso-file' "$1"
          shift
        fi
        ;;
      *)
        _setUserVar 'iso-file' "$1"
        shift
        ;;
      esac
    else
      _setUserVar 'iso-file' "$1"
      break
    fi
  done
}

step_assignInternalVariables() {
  # Command argument
  sourceImageFile=${userVars['iso-file']:-''}
  # Option flags
  disableConfirmation=${userFlags['assume-yes']:-'false'}
  autoselect=${userFlags[autoselect]:-'false'}
  enforceGPT=${userFlags[gpt]:-'false'}
  localBootloader=${userFlags['local-bootloader']:-'false'}
  disableMimeCheck=${userFlags['no-mime-check']:-'false'}
  disableUSBCheck=${userFlags['no-usb-check']:-'false'}
  disableSizeCheck=${userFlags['no-size-check']:-'false'}
  disableHashCheck=${userFlags['no-hash-check']:-'false'}
  forceHashCheck=${userFlags['force-hash-check']:-'false'}
  disableWimsplit=${userFlags['no-wimsplit']:-'false'}
  enableDataPart=${userFlags['data-part']:-'false'}
  # Vars flags
  targetFilesystem=${userVars[fs]:-'vfat'}
  targetPartitionScheme=${userVars['part-type']}
  sourceHashFile=${userVars['hash-file']:-''}
  targetDevice=${userVars[device]:-''}
  targetPartitionLabel=${userVars[label]:-''}
  targetBootloaderVersion=${userVars['remote-bootloader']:-'auto'}
  ddBusSize=${userVars['dd-bs']:-'4M'}
  dataPartFstype=${userVars['data-part-fs']:-'vfat'}
  # Action-dependent flags
  case $targetAction in
  install-*)
    hasActionDuration='true'
    expectingISOFile='true'
    requiresRoot='true'
    noDeviceEjection=${userFlags['no-eject']:-'false'}
    ;;
  format)
    hasActionDuration='true'
    expectingISOFile='false'
    requiresRoot='true'
    ;;
  version)
    hasActionDuration='false'
    expectingISOFile='false'
    requiresRoot='false'
    ;;
  help | list-usb-drives)
    hasActionDuration='false'
    expectingISOFile='false'
    requiresRoot='false'
    ;;
  inspect | probe)
    hasActionDuration='false'
    expectingISOFile='true'
    requiresRoot='true'
    ;;
  *)
    prog_failAndExit "${prog_exitStatus[INTERNALST]}" "Unhandled targetAction $(term_boldify "$targetAction")."
    ;;
  esac
}

step_stopTimerAndPrintLapsed() {
  transientEndTime=$(date +%s)
  term_echogood "Took $((transientEndTime - transientStartTime)) seconds to perform $(term_boldify "$targetAction") targetAction."
}

step_runSecurityAssessments() {
  devi_configureLabel
  devi_selectDevice
  prog_startTimer
  asrt_checkDeviceIsOK "$targetDevice"
  asrt_checkDeviceIsUSB
  asrt_checkImageSize "$targetDevice" "$sourceImageFile"
}

step_checkArguments() {
  asrt_checkAction
  asrt_checkUserVars
  asrt_checkUserFlags
}

#  .ooooo.  oooo    ooo  .ooooo.   .ooooo.
# d88' `88b  `88b..8P'  d88' `88b d88' `"Y8
# 888ooo888    Y888'    888ooo888 888
# 888    .o  .o8"'88b   888    .o 888   .o8
# `Y8bod8P' o88'   888o `Y8bod8P' `Y8bod8P'
#
# EXEC (ACTION) MODULE
#
# Very-high level functions corresponding to program actions.
# Functions belonging to this module are prefixed with "exec_"

exec_help() {
  local _termWidth
  local -r _actionFlagsTable=$(printf "%s\n" \
    "-f, --format|Format selected USB drive and exit." \
    "-h, --help|Display this help message and exit." \
    "-i, --inspect|Inspect <imagefile> boot capabilities." \
    "-l, --list-usb-drives|List available USB drives and exit." \
    "-p, --probe|Equivalent to -i followed by -l actions.")
  local -r _modifierFlagsTable=$(printf "%s\n" \
    "-a, --autoselect|In combination with -y, autoselect USB drive when only one is connected." \
    "-d, --device <device>|Pick <device> block file as target USB drive." \
    "-F, --fstype <fstype>|Format to <fstype>." \
    "-H, --no-hash-check|Don't search for hash files and check <imagefile> integrity." \
    "-J, --no-eject|Don't eject drive after unmounting." \
    "-L, --label <label>|Set partition label to <label>." \
    "-M, --no-mime-check|Don't check <imagefile> mime-type." \
    "-y, --assume-yes|Don't prompt for confirmation before erasing drive.")
  local -r _installModeModifiersTable=$(printf "%s\n" \
    "--icopy, --dd|Assert \"Image-Copy\" install mode." \
    "--mrsync|Assert \"Mount-Rsync\" install mode.")
  local -r _helpIntro="$scriptName v$version - create a bootable USB drive from an image file."
  local -r _helpSynopsis=$(printf "%s\n" \
    "Usage: $(term_boldify "$scriptName") [$(term_underline modifier...)] <imagefile>" \
    "       $(term_boldify "$scriptName") $(term_underline targetAction) [$(term_underline modifier...)] <imagefile>" \
    "       $(term_boldify "$scriptName") $(term_underline targetAction)")
  local -r _helpHint=$(printf "%s" \
    "\nInvoked with no targetAction flag, $scriptName will default to install targetAction in automatic mode: inspect <imagefile>" \
    "boot capabilities and find the best way to make a bootable USB drive.")

  _termWidth=$(tput cols)
  echo -e "$_helpIntro" | fmt -g "$_termWidth" -w "$_termWidth"
  echo -e "$_helpSynopsis"
  echo -e "$_helpHint" | fmt -g "$_termWidth" -w "$_termWidth"
  echo -e "\n$(term_boldify 'ACTIONS')"
  echo -e "$_actionFlagsTable" | column -c "$_termWidth" --table -d -N flag,desc -W desc -s \|
  echo -e "\n$(term_boldify 'GENERIC MODIFIERS')"
  echo -e "$_modifierFlagsTable" | column -c "$_termWidth" --table -d -N flag,desc -W desc -s \|
  echo -e "\nAdvanced modifiers are described in $scriptName man page." | fmt -g "$_termWidth" -w "$_termWidth"
  echo -e "\n$(term_boldify 'INSTALL MODE MODIFIERS')"
  echo -e "$_installModeModifiersTable" | column -c "$_termWidth" --table -d -N flag,desc -W desc -s \|
}

exec_listUSBDrives() {
  # Run udevadm settle
  local _lsblkCmd='lsblk -d -l -o NAME,MODEL,VENDOR,SIZE,TRAN,HOTPLUG'
  step_initDevicesList
  if [ "$disableUSBCheck" == 'true' ]; then
    term_echoinfo "Listing drives available in your system:"
  else
    term_echoinfo "Listing USB devices available in your system:"
  fi
  if [ "${#devicesList[@]}" -gt 0 ]; then
    $_lsblkCmd "${devicesList[@]/#/\/dev\/}" | sed "s/^/$term_logPrefixEmpty/"
    return 0
  else
    term_echowarn "Couldn't find any USB drives on your system." \
      "If one is physically plugged in, it's likely that it has been ejected and should be reconnected." \
      "You can check the availability of USB drives with $(term_boldify "$scriptName -l")."
    return 1
  fi
}

exec_inspect() {
  local _uefiCompatible=${isoInspections[supportsEFIBoot]}
  local _biosCompatible=${isoInspections[supportsBIOSBoot]}
  local _syslinuxCompatible=false
  local _isHybrid=${isoInspections[isHybrid]}
  local _syslinux='SYSLINUX'
  local _localSyslinuxVersion
  if [ ! -z "${isoInspections[syslinuxConf]}" ]; then
    _syslinuxCompatible=true
  fi
  if [ ! -z "${isoInspections[syslinuxVer]}" ]; then
    _syslinux+=" ${isoInspections[syslinuxVer]}"
  fi
  term_echoinfo "Reporting '$(basename "$sourceImageFile")' boot capabilities:"
  if [ "$_isHybrid" == false ] && [ "$_syslinuxCompatible" == false ] && [ "$_uefiCompatible" == false ]; then
    term_echoerr "The selected image is not hybrid, doesn't support UEFI or legacy BIOS booting nor SYSLINUX." \
      "It cannot result in any successful booting with $scriptName."
  elif [ "$_isHybrid" == false ] && [ "$_syslinuxCompatible" == true ] && [ "$_uefiCompatible" == false ]; then
    term_echogood "The selected image is not hybrid, but supports legacy BIOS booting with $_syslinux." \
      "It should boot with $scriptName in $(term_boldify install) 'Automatic' and 'Mount-Rsync' modes with BIOS-boot capable PCs."
  elif [ "$_isHybrid" == false ] && [ "$_syslinuxCompatible" == false ] && [ "$_uefiCompatible" == true ]; then
    term_echogood "The selected image is not hybrid, but supports UEFI boot." \
      "It should boot with $scriptName in $(term_boldify install) 'Automatic' and 'Mount-Rsync' modes with modern UEFI-capable PCs."
  elif [ "$_isHybrid" == false ] && [ "$_syslinuxCompatible" == true ] && [ "$_uefiCompatible" == true ]; then
    term_echogood "The selected image is not hybrid, but supports legacy BIOS booting with $_syslinux and UEFI boot." \
      "It should boot with $scriptName in $(term_boldify install) 'Automatic' and 'Mount-Rsync' modes with any PCs."
  elif [ "$_isHybrid" == true ] && [ "$_syslinuxCompatible" == false ] && [[ "$_biosCompatible" == false ]] && [ "$_uefiCompatible" == false ]; then
    term_echowarn "The selected image is hybrid, but doesn't support UEFI or legacy BIOS bootloader." \
      "It should boot with $scriptName in $(term_boldify install) 'Automatic' and 'Image-Copy' modes, but $scriptName is not aware of its booting scheme."
  elif [ "$_isHybrid" == true ] && [ "$_syslinuxCompatible" == true ] && [ "$_uefiCompatible" == false ]; then
    term_echogood "The selected image is hybrid and supports legacy BIOS booting with $_syslinux." \
      "It should boot with $scriptName in $(term_boldify install) 'Automatic' and 'Image-Copy' modes with BIOS-boot capable PCs."
  elif [ "$_isHybrid" == true ] && [ "$_biosCompatible" == true ] && [ "$_uefiCompatible" == false ]; then
    term_echogood "The selected image is hybrid and supports legacy BIOS booting." \
      "It should boot with $scriptName in $(term_boldify install) 'Automatic' and 'Image-Copy' modes with BIOS-boot capable PCs."
  elif [ "$_isHybrid" == true ] && [ "$_syslinuxCompatible" == false ] && [ "$_uefiCompatible" == true ]; then
    term_echogood "The selected image is hybrid and supports UEFI boot." \
      "It should boot with $scriptName in $(term_boldify install) 'Automatic' and 'Image-Copy' modes with modern UEFI-capable PCs."
  elif [ "$_isHybrid" == true ] && [ "$_syslinuxCompatible" == true ] && [ "$_uefiCompatible" == true ]; then
    term_echogood "The selected image is hybrid and supports legacy BIOS booting with $_syslinux along with UEFI boot." \
      "It should boot with $scriptName in $(term_boldify install) 'Automatic' and 'Image-Copy' modes with any PCs."
  elif [ "$_isHybrid" == true ] && [ "$_biosCompatible" == true ] && [ "$_uefiCompatible" == true ]; then
    term_echogood "The selected image is hybrid and supports legacy BIOS boot along with UEFI boot." \
      "It should boot with $scriptName in $(term_boldify install) 'Automatic' and 'Image-Copy' modes with any PCs."
  else
    prog_failAndExit "${prog_exitStatus[INTERNALST]}" "Unexpected state. isHybrid: $_isHybrid, biosCompatible: $_biosCompatible," \
      "uefiCompatible: $_uefiCompatible, syslinuxCompatible: $_syslinuxCompatible"
  fi
  if [[ "$_uefiCompatible" == false && ("$_syslinuxCompatible" == true || "$_biosCompatible" == true) ]]; then
    term_echowarn "You might have to enable CSM in your UEFI system for legacy BIOS-boot suport."
  fi
  _localSyslinuxVersion=$(syslinux --version |& grep -oP '(\d+\.\d+)')
  if [ "$_syslinuxCompatible" == true ] && [ ! -z "${isoInspections[syslinuxVer]}" ] && [ "$_isHybrid" == false ]; then
    if prim_compute "$_localSyslinuxVersion == ${isoInspections[syslinuxVer]}"; then
      term_echogood "Furthermore, SYSLINUX version in the image file matches local version (${isoInspections[syslinuxVer]})."
    elif prim_compute "${_localSyslinuxVersion%.*} == ${isoInspections[syslinuxVer]%.*}"; then
      term_echoinfo "However, SYSLINUX version (${isoInspections[syslinuxVer]}) in the image file doesn't match the minor part of local version ($_localSyslinuxVersion), which should not cause any problems."
    else
      term_echowarn "SYSLINUX version (${isoInspections[syslinuxVer]}) in the image file doesn't match the major part of local version ($_localSyslinuxVersion)." \
        "$scriptName will try to download and execute this version from kernel.org, unless given the modifier $(term_boldify '--local-bootloader')." \
        "If that fails, it will attempt installation with the local version of SYSLINUX."
    fi
  fi
}

exec_probe() {
  exec_inspect
  exec_listUSBDrives
}

exec_installMountRsync() {
  if [ "${isoInspections[isHybrid]}" == true ]; then
    prog_failAndExit "${prog_exitStatus[ASSERTFAIL]}" "You cannot set Mount-Rsync mode with a hybrid image file." \
      "Hybrid ISO or disk image files eventually contain multiple partitions and Mount-Rsync mode can only work with one." \
      "If you think this image file is not hybrid and this is a bug, please report at " \
      "${prog_ticketsurl}."
  fi
  shouldMakePartition=true
  asrt_checkSyslinuxInstall
  asrt_inspectImageBootCapabilities
  step_runSecurityAssessments
  transientElToritoMountPoint=$(fs_createMountFolder iso) || exit "$?"
  fs_mountElToritoFile "$transientElToritoMountPoint"
  devi_partitionUSB false
  fs_mountUSB
  step_copyWithRsync
  if [ "$transientShouldInstallSyslinux" == true ]; then
    step_installBootloader
  fi
}

exec_installImageCopy() {
  if [ "${isoInspections[isHybrid]}" == false ]; then
    prog_failAndExit "${prog_exitStatus[ASSERTFAIL]}" "You cannot set Image-Copy mode with a non-hybrid, 'El-Torito' image file." \
      "El-Torito image files don't have a partition table; and thus target device will not be recognized" \
      "by any boot system as a boot candidate. If you think this image file is hybrid and this is a bug, please report at " \
      "${prog_ticketsurl}."
  fi
  shouldMakePartition=false
  step_runSecurityAssessments
  devi_partitionUSB false
  step_copyWithDD
  if [[ "$enableDataPart" == true ]]; then
    devi_addDataPartition
    case "$?" in
    1) term_echoerr "Could not append partition table to add data partition" ;;
    2) term_echoerr "Could not format data partition" ;;
    esac
  fi

}

exec_installAuto() {
  if [ "${isoInspections[isHybrid]}" == true ]; then
    term_echogood "Found hybrid image; choosing Image-Copy mode."
    exec_installImageCopy
  else
    term_echoinfo "Found non-hybrid image; inspecting image for boot capabilities..."
    exec_installMountRsync
  fi
}

exec_format() {
  shouldMakePartition=true
  devi_selectDevice
  prog_startTimer
  devi_configureLabel
  asrt_checkDeviceIsOK "$targetDevice"
  asrt_checkDeviceIsUSB
  devi_partitionUSB true
}

exec_version() {
  echo "$version"
}

#                              o8o
#                              `"'
# ooo. .oo.  .oo.    .oooo.   oooo  ooo. .oo.
# `888P"Y88bP"Y88b  `P  )88b  `888  `888P"Y88b
#  888   888   888   .oP"888   888   888   888
#  888   888   888  d8(  888   888   888   888
# o888o o888o o888o `Y888""8o o888o o888o o888o
#
# MAIN PROGRAM EXECUTION

main() {
  mkdir -p "$prog_tempRoot"
  step_initPckgManager "$@"
  step_parseArguments "$@"
  step_checkArguments
  step_assignInternalVariables
  asrt_checkFlagMatrix
  asrt_checkPackages
  if [ "$requiresRoot" == 'true' ]; then
    asrt_checkSudo "$@"
    fs_configureFolders
  fi
  if [ "$expectingISOFile" == 'true' ]; then
    asrt_checkFileIsImage
    if [ "$disableHashCheck" == false ]; then
      asrt_checkImageHash
    else
      term_echowarn "Skipping hash check with $(term_boldify '-H, --no-hash-check') flag"
    fi
    step_inspectImageFile
  fi
  case "$targetAction" in
  'install-auto') exec_installAuto "$@" ;;
  'install-image-copy') exec_installImageCopy "$@" ;;
  'install-mount-rsync') exec_installMountRsync "$@" ;;
  'format') exec_format "$@" ;;
  'inspect') exec_inspect ;;
  'probe') exec_probe "$@" ;;
  'list-usb-drives') exec_listUSBDrives ;;
  'version') exec_version ;;
  'help') exec_help ;;
  *) prog_failAndExit "${prog_exitStatus[INTERNALST]}" "(main) unexpected targetAction $(term_boldify "$targetAction")." ;;
  esac
  if [ "$hasActionDuration" == 'true' ]; then
    step_stopTimerAndPrintLapsed
  fi
  completedAction=$targetAction
}

trap prog_cleanup EXIT INT TERM
main "$@"
