#!/bin/bash
# shellcheck disable=SC2181
# shellcheck disable=SC2236
#
# Author: jules randolph <jules.sam.randolph@gmail.com> https://github.com/jsamr
# License: MIT
# Version 4.0.0-alpha.0

set -o pipefail
set -E

version="4.0.0-alpha.0"
scriptName=$(basename "$0")
bashVersion=$(echo "$BASH_VERSION" | cut -d. -f1)

if [ -z "$BASH_VERSION" ] || [ "$bashVersion" -lt 4 ]; then
  echo >&2 "You need bash v4+ to run this script. Aborting..."
  exit 1
fi

# program constrains definitions
typeset -ar commandDependencies=('lsblk' 'column' 'sfdisk' 'mkfs' 'blkid' 'wipefs' 'blockdev' 'grep' 'file' 'awk' 'mlabel' 'syslinux' 'rsync'
  'partprobe' 'curl' 'cat' 'tar' 'bc' 'wimlib-imagex' 'md5sum' 'sha1sum' 'sha256sum' 'sha512sum' 'cut' 'jq')
typeset -Ar commandPackages=(
  ['lsblk']='util-linux'
  ['mount']='util-linux'
  ['umount']='util-linux'
  ['sfdisk']='util-linux'
  ['mkfs']='util-linux'
  ['blkid']='util-linux'
  ['wipefs']='util-linux'
  ['blockdev']='util-linux'
  ['column']='util-linux'
  ['blockdev']='util-linux'
  ['grep']='grep'
  ['sed']='sed'
  ['file']='file'
  ['awk']='gawk'
  ['mlabel']='mtools'
  ['syslinux']='syslinux'
  ['rsync']='rsync'
  ['partprobe']='parted'
  ['curl']='curl'
  ['tar']='tar'
  ['bc']='bc'
  ['wimlib-imagex']='wimlib'
  ['jq']='jq'
  ['find']='findutils'
  ['find']='findutils'
  ['md5sum']='coreutils'
  ['sha1sum']='coreutils'
  ['sha256sum']='coreutils'
  ['sha512sum']='coreutils'
  ['cut']='coreutils'
  ['cat']='coreutils'
  ['mkdir']='coreutils'
  ['chmod']='coreutils'
  ['dirname']='coreutils'
  ['basename']='coreutils'
  ['date']='coreutils'
  ['tr']='coreutils'
)
typeset shortOptions='bydJahlMftLp'
typeset -ar supportedFS=('vfat' 'exfat' 'ntfs' 'ext2' 'ext3' 'ext4' 'f2fs')
typeset -Ar userVarsCompatibilityMatrix=(
  ['iso-file']='install-auto install-mount-rsync install-image-copy inspect probe'
  ['hash-file']='install-auto install-mount-rsync install-image-copy inspect probe'
  ['device']='install-auto install-mount-rsync install-image-copy format'
  ['type']='install-mount-rsync format'
  ['label']='install-mount-rsync format'
  ['remote-bootloader']='install-mount-rsync'
  ['partype']='format install-mount-rsync'
  ['dd-bs']='install-image-copy'
)
typeset -Ar userFlagsCompatibilityMatrix=(
  ['assume-yes']='install-auto install-mount-rsync install-image-copy format'
  ['no-eject']='install-auto install-mount-rsync install-image-copy format'
  ['autoselect']='install-auto install-mount-rsync install-image-copy format'
  ['no-mime-check']='install-auto install-mount-rsync install-image-copy probe inspect'
  ['no-hash-check']='install-auto install-mount-rsync install-image-copy probe inspect'
  ['force-hash-check']='install-auto install-mount-rsync install-image-copy probe inspect'
  ['no-usb-check']='install-auto install-mount-rsync install-image-copy list-usb-drives probe format'
  ['no-size-check']='install-auto install-mount-rsync install-image-copy'
  ['gpt']='format install-mount-rsync'
  # Mount-Rsync specials
  ['local-bootloader']='install-mount-rsync'
  ['no-wimsplit']='install-mount-rsync'
)

# internal variables
typeset syslinuxLibRoot=${BOOTISO_SYSLINUX_LIB_ROOT:-'/usr/lib/syslinux'}
typeset ticketsurl="https://github.com/jsamr/bootiso/issues"
typeset mountRoot=/mnt
typeset tempRoot=/var/tmp/bootiso
typeset cacheRoot=/var/cache/bootiso
typeset selectedPartition
typeset elTorinoMountPoint
typeset usbMountPoint
typeset startTime
typeset endTime
typeset addSyslinuxBootloader=false
typeset syslinuxVersion
typeset -a devicesList
typeset operationSuccess
typeset expectingISOFile
typeset foundSyslinuxMbrBinary
typeset foundSyslinuxBiosFolder
typeset logPrefix="$scriptName: "
typeset logPrefixLength="${#logPrefix}"
typeset logPrefixEmpty="$(printf "%${logPrefixLength}s")"
typeset -A syslinuxInstall
typeset -a temporaryAssets=()
typeset -A isoInspection=(
  [syslinuxBin]=''
  [syslinuxVer]=''
  [syslinuxConf]=''
  [isHybrid]=false
  [supportsEFIBoot]=false
  [supportsBIOSBoot]=false
  [hasWimFile]=false
)
typeset -A userFlags=(
  # Actions
  ['help']=''
  ['version']=''
  ['list-usb-drives']=''
  ['format']=''
  ['install-image-copy']=''
  ['install-mount-rsync']=''
  ['inspect']=''
  ['probe']=''
  # Options
  ['local-bootloader']=''
  ['assume-yes']=''
  ['device']=''
  ['no-eject']=''
  ['gpt']=''
  ['autoselect']=''
  ['no-mime-check']=''
  ['no-usb-check']=''
  ['no-size-check']=''
  ['no-hash-check']=''
  ['force-hash-check']=''
  ['no-wimsplit']=''
)
typeset -A userVars=(
  ['iso-file']=''
  ['hash-file']=''
  ['device']=''
  ['type']=''
  ['label']=''
  ['remote-bootloader']=''
  ['partype']=''
)

typeset -A exitStatus=(
  # Exceptions
  [ASSERTFAIL]=1
  [SYNOPSISNC]=2
  [MISBOOTCAP]=3
  [MISFILE]=4
  [BADFILE]=5
  [MISDEV]=6
  [BADDEV]=7
  [NODEV]=8
  [MISDEP]=9
  [HOSTUNR]=10
  [USERABORT]=11
  [MISPRIVILEGE]=12
  # Errors
  [INTERNALIO]=64
  [INTERNALST]=65
  [INTERNALTP]=66
)

typeset -A gptPartitionCodes=(
  [efi]="C12A7328-F81F-11D2-BA4B-00A0C93EC93B"
  # Windows Data partition
  [wdp]="EBD0A0A2-B9E5-4433-87C0-68B6B72699C7"
  # Linux Filesystem Data
  [lfd]="0FC63DAF-8483-4772-8E79-3D69D8477DE4"
)

typeset -A mbrPartitionCodes=(
  [efi]=ef
)

# user defined variables
typeset selectedIsoFile # no default
typeset hashFile
typeset selectedDevice # default to prompted to user
typeset partitionLabel # default to inferred from image file label
typeset filesystemType # default to vfat
typeset partitionType  # GPT or MBR partition type
typeset action='install-auto'
typeset selectedBootloaderVersion # default to auto

# options
typeset disableMimeCheck
typeset disableUSBCheck
typeset disableSizeCheck
typeset disableConfirmation
typeset disableHashCheck
typeset forceHashCheck
typeset disableWimsplit
typeset autoselect
typeset shouldMakePartition
typeset noDeviceEjection
typeset localBootloader
typeset enforceGPT
typeset ddBusSize

# See console_codes GNU-Linux man page
typeset setRed="\e[31m"
typeset setGreen="\e[32m"
typeset setYellow="\e[33m"
typeset unsetColor="\e[39m"
typeset setUnderline="\e[4m"
typeset unsetUnderline="\e[24m"
typeset setBold="\e[1m"
typeset unsetBold="\e[22m"

boldify() {
  echo -e "$setBold$1$unsetBold"
}

underline() {
  echo -e "$setUnderline$1$unsetUnderline"
}

# $1: The text to colorify.
redify() {
  echo -e "$setRed$1$unsetColor"
}

# $1: The text to colorify.
greenify() {
  echo -e "$setGreen$1$unsetColor"
}

# $1: The text to colorify.
yellowify() {
  echo -e "$setYellow$1$unsetColor"
}

typeset openTicketMessage="This is not expected: please open a ticket at $ticketsurl."

typeset actionFlagsTable="
-f, --format|Format selected USB drive and exit.
-h, --help|Display this help message and exit.
-i, --inspect|Inspect <imagefile> boot capabilities.
-l, --list-usb-drives|List available USB drives and exit.
-p, --probe|Equivalent to -i followed by -l actions.
-v, --version|Display version and exit.
"

typeset modifierFlagsTable="
-a, --autoselect|In combination with -y, autoselect USB drive when only one is connected.
-d, --device <device>|Pick <device> block file as target USB drive.
-H, --no-hash-check|Don't search for hash files and check <imagefile> integrity.
-J, --no-eject|Don't eject drive after unmounting.
-L, --label <label>|Set partition label to <label>.
-M, --no-mime-check|Don't check <imagefile> mime-type.
-t, --type <fstype>|Format to <fstype>.
-y, --assume-yes|Don't prompt for confirmation before erasing drive.
"

typeset installModeModifiersTable="
--icopy, --dd|Assert \"Image-Copy\" install mode.
--mrsync|Assert \"Mount-Rsync\" install mode.
"
typeset helpIntro="\
$scriptName v$version - create a bootable USB drive from an image file."

typeset helpSynopsis="
Usage: $(boldify "$scriptName") [$(underline modifier...)] <imagefile>
       $(boldify "$scriptName") $(underline action) [$(underline modifier...)] <imagefile>
       $(boldify "$scriptName") $(underline action)"

typeset helpHint="
Invoked with no action flag, $scriptName will default to install action in automatic mode: inspect <imagefile> \
boot capabilities and find the best way to make a bootable USB drive."

displayHelp() {
  local termwidth
  termwidth=$(tput cols)
  echo -e "$helpIntro" | fmt -g "$termwidth" -w "$termwidth"
  echo -e "$helpSynopsis"
  echo -e "$helpHint" | fmt -g "$termwidth" -w "$termwidth"
  echo -e "\n$(boldify 'ACTIONS')"
  echo -e "$actionFlagsTable" | column -c "$termwidth" --table -d -N flag,desc -W desc -s \|
  echo -e "\n$(boldify 'GENERIC MODIFIERS')"
  echo -e "$modifierFlagsTable" | column -c "$termwidth" --table -d -N flag,desc -W desc -s \|
  echo -e "\nAdvanced modifiers are described in $scriptName man page." | fmt -g "$termwidth" -w "$termwidth"
  echo -e "\n$(boldify 'INSTALL MODE MODIFIERS')"
  echo -e "$installModeModifiersTable" | column -c "$termwidth" --table -d -N flag,desc -W desc -s \|
}

printColumn() {
  local prefix=$1
  local prefixLength=$2
  local cols
  local sep='\t'
  cols="$(tput cols)"
  shift 2
  local rawInput="$*"
  echo -n -e "$prefix$sep$prefixLength$sep$cols$sep$rawInput" | awk -F $sep '
{
  prefix = $1
  prefixlen = $2
  termwidth = $3
  len = prefixlen
  printargfill = sprintf("%s%s%s", "%-", prefixlen, "s")
  printf printargfill, prefix
  for(j=4;j<=NF;j++) {
    n = split($j,x," ")
    for(i=1;i<=n;i++){
      if(len+length(x[i])>=termwidth){
        print ""
        printf printargfill, " "
        len = prefixlen
      }
      printf "%s ",x[i]
      len += 1+length(x[i])
    }
  }
  print ""
}'
}

printLog() {
  printColumn "$logPrefix" "$logPrefixLength" "$*"
}

# shellcheck disable=SC2120
indentAll() {
  while read -r line; do
    printColumn " " "$logPrefixLength" "$line"
  done <"${1:-/dev/stdin}"
}

# $*: The message to print.
echoerr() {
  redify "$(printLog "$*")"
}

# $*: The message to print.
echowarn() {
  yellowify "$(printLog "$*")"
}

# $*: The message to print.
echogood() {
  greenify "$(printLog "$*")"
}

# $*: The message to print.
echoinfo() {
  printLog "$*"
}

# $*: The message to print.
failAndExit() {
  local status=$1
  if ! [[ $status =~ ^[0-9]+$ ]]; then
    echoerr "(failAndExit) Internal state error."
    status="${exitStatus[INTERNALST]}"
  else
    shift
    if [ "$status" -eq "${exitStatus[SYNOPSISNC]}" ]; then
      [ $# -ne 0 ] && echoerr "$@"
      echoerr "Check $(boldify 'man 1 bootiso')."
    else
      echoerr "$@" "Exiting..."
    fi
  fi
  exit "$status"
}

syncdev() {
  sync
}

compute() {
  answer=$(echo "$@" | bc)
  if ((answer == 0)); then
    return 1
  else
    return 0
  fi
}

# $1: The name of the command to check against $PATH.
hasPackage() {
  command -v "$1" &>/dev/null
  return $?
}

configureFolders() {
  local defaultMode=777
  if [ ! -e "$tempRoot" ]; then
    mkdir -m $defaultMode "$tempRoot"
  elif [ -d "$tempRoot" ]; then
    chmod -R $defaultMode "$tempRoot"
  else
    failAndExit "${exitStatus[INTERNALST]}" "(configureFolders) '$tempRoot' is not a folder." \
      "Remove this file and try again."
  fi
  if [ ! -e "$cacheRoot" ]; then
    mkdir -m $defaultMode "$cacheRoot"
  elif [ -d "$cacheRoot" ]; then
    chmod -R $defaultMode "$cacheRoot"
  else
    failAndExit "${exitStatus[INTERNALST]}" "(configureFolders) '$cacheRoot' is not a folder." \
      "Remove this file and try again."
  fi
  if [ ! -e "$mountRoot" ]; then
    mkdir "$mountRoot"
  elif [ ! -d "$mountRoot" ]; then
    failAndExit "${exitStatus[INTERNALST]}" "(configureFolders) '$mountRoot' is not a folder." \
      "Remove this file and try again."
  fi
}

isMounted() {
  if [ ! -z "$1" ] && grep -q -e "$1" /etc/mtab; then
    return 0
  else
    return 1
  fi
}

umountUSB() {
  if isMounted "$usbMountPoint"; then
    if umount "$usbMountPoint" |& indentAll; then
      echogood "USB device partition succesfully unmounted."
    else
      echowarn "Could not unmount USB mount point."
    fi
  fi
}

# $1: mountPoint
unmountPartition() {
  local mountPoint="$1"
  if isMounted "$mountPoint"; then
    if ! umount "$mountPoint" |& indentAll; then
      echowarn "Could not unmount image mount point."
    fi
  fi
}

umountElTorino() {
  if isMounted "$elTorinoMountPoint"; then
    if ! umount "$elTorinoMountPoint" |& indentAll; then
      echowarn "Could not unmount image mount point."
    fi
  fi
}

initPckgManager() {
  if hasPackage apt-get; then # Debian
    pkgmgr="apt-get install"
    return 0
  fi
  if hasPackage dnf; then # Fedora
    pkgmgr="dnf install"
    return 0
  fi
  if hasPackage yum; then # Fedora
    pkgmgr="yum install"
    return 0
  fi
  if hasPackage pacman; then # Arch
    pkgmgr="pacman -S"
    return 0
  fi
  if hasPackage zypper; then # OpenSuse
    pkgmgr="zypper install"
    return 0
  fi
  if hasPackage emerge; then # Gentoo
    pkgmgr="emerge"
    return 0
  fi
  if hasPackage xbps-install; then # Void
    pkgmgr="xbps-install"
    return 0
  fi
  if hasPackage eopkg; then # Solus
    pkgmgr="eopkg install"
    return 0
  fi
  return 1
}

checkSudo() {
  if ((EUID != 0)); then
    if [[ -t 1 ]] && command -v sudo &>/dev/null; then
      sudo --preserve-env "$0" "$@"
    elif command -v gksu &>/dev/null; then
      exec 1>output_file
      gksu --preserve-env "$0" "$@"
    else
      failAndExit "${exitStatus[MISPRIVILEGE]}" "You must run $scriptName as root."
    fi
    exit
  fi
}

failISOCheck() {
  echoerr "Provided file '$selectedIsoFile' doesn't seem to be an image file (wrong mime-type: '$mimetype')." \
    "You can bypass this policy with $(boldify '-M, --no-mime-check')."
  failAndExit "${exitStatus[BADFILE]}"
}

assertISOIsOK() {
  local mimetype
  local -i isOctetStream
  if [ -z "$selectedIsoFile" ]; then
    echoerr "Missing argument 'iso-file'."
    exit 2
  fi
  if [ -d "$selectedIsoFile" ]; then
    failAndExit "${exitStatus[BADFILE]}" "Provided file '$selectedIsoFile' is a directory."
  fi
  if [ ! -f "$selectedIsoFile" ]; then
    failAndExit "${exitStatus[MISFILE]}" "Provided iso file '$selectedIsoFile' does not exist."
  fi
  if [ "$disableMimeCheck" == false ]; then
    mimetype=$(file --mime-type -b -- "$selectedIsoFile")
    [ "$mimetype" == "application/octet-stream" ]
    isOctetStream=$?
    if ((isOctetStream != 0)) && [ ! "$mimetype" == "application/x-iso9660-image" ]; then
      failISOCheck
    fi
  fi
}

checkISOHash() {
  local lHash
  computeHashWithProgress() {
    local hashName="$1"
    local isoName="$2"
    local hashStoreFile
    hashStoreFile=$(createTempFile "bootiso-file-hash")
    echoinfo "Checking hash for '$isoName'..."
    printf "%s%s" \
      "You can disable this check with $(boldify "-H, --no-hash-check") flags" \
      "    " | indentAll
    temporaryAssets+=("$hashStoreFile")
    (
      local hash
      local -i status=0
      hash=$($hashName "$isoName" | awk "{print \$1; exit }")
      status=$?
      if ((status == 0)); then
        printf "%s" "$hash" >"$hashStoreFile"
      else
        printf "%s" 1 >"$hashStoreFile"
      fi
    ) &
    pid=$!
    while [ -e "/proc/$pid" ]; do
      updateProgress
    done
    cleanProgress
    lHash=$(cat "$hashStoreFile")
    if [ "$lHash" == "1" ]; then
      return 1
    fi
  }
  checkHash() {
    local hashPath=$1 # Path to file containing hashes
    local isoName=$2  # File to be checked
    local hashName=$3 # Name of command of hash
    local status
    # Hash from hash file
    local gHash
    gHash=$(awk -v pattern="$isoName$" '$0 ~ pattern { print $1; exit }' "$hashPath")
    if [ -z "$gHash" ]; then
      echoerr "No matching filename found in hash file '$hashPath'"
      return
    elif [ -z "$hashName" ]; then
      case ${#gHash} in
      32)
        hashName="md5sum"
        ;;
      40)
        hashName="sha1sum"
        ;;
      64)
        hashName="sha256sum"
        ;;
      128)
        hashName="sha512sum"
        ;;
      *)
        failAndExit "${exitStatus[BADFILE]}" "Matching line in '$hashPath' has an unexpected hash format."
        ;;
      esac
    fi
    # Hash from iso
    computeHashWithProgress $hashName "$isoName"
    status=$?
    if ((status != 0)); then
      failAndExit "${exitStatus[INTERNALTP]}" "$hashName command failed with status $status"
    fi
    if [ "$gHash" != "$lHash" ]; then
      if [ "$forceHashCheck" == 'true' ]; then
        failAndExit "${exitStatus[ASSERTFAIL]}" "Hash mismatch in '$hashPath' (${hashName%sum})."
      else
        echowarn "Hash mismatch in '$hashPath' (${hashName%sum})."
        local answer
        read -r -n1 -p "${logPrefixEmpty}Do you still want to continue? (y/n)> " answer
        echo
        case $answer in
        y | Y)
          return
          ;;
        *)
          failAndExit "${exitStatus[USERABORT]}"
          ;;
        esac
        echoinfo "Ignoring mismatching hash."
      fi
    else
      echogood "Matching ${hashName%sum} hash found in '$hashPath'"
      numValidHashes=$((numValidHashes + 1))
    fi
  }

  local numValidHashes=0
  local isoDirectory
  local isoFileName
  local -ar hashes=("md5sum" "sha1sum" "sha256sum" "sha512sum")
  isoDirectory=$(dirname "$selectedIsoFile")
  isoFileName=$(basename "$selectedIsoFile")
  if [ -n "$hashFile" ]; then
    if [ -f "$hashFile" ]; then
      checkHash "$hashFile" "$isoFileName"
    else
      failAndExit "${exitStatus[MISFILE]}" "Specified hash file '$hashFile' does not exist."
    fi
  else
    shopt -s nullglob nocaseglob
    for hash in "${hashes[@]}"; do
      for file in "$isoDirectory/$hash"*; do
        checkHash "$file" "$isoFileName" "$hash"
      done

      if [ -f "$selectedIsoFile.${hash%sum}" ]; then
        checkHash "$selectedIsoFile.${hash%sum}" "$isoFileName" "$hash"
      fi
    done
    shopt -u nullglob nocaseglob
  fi

  if [ "$forceHashCheck" == 'true' ] && [ $numValidHashes == 0 ]; then
    failAndExit "${exitStatus[ASSERTFAIL]}" "No matching hashes found. Assert forced by $(boldify '--force-hash-check')"
  fi
}

firstMatchInFolder() {
  find "$1" -type f -iname "$2" -print -quit
}

matchFirstExpression() {
  local root=$1
  local expr
  local match
  shift
  for expr in "$@"; do
    match=$(firstMatchInFolder "$root" "$expr")
    if [ ! -z "$match" ]; then
      echo "$match"
      break
    fi
  done
}

findFileFromPatterns() {
  local root=$1
  shift
  local loc
  local found
  local candidate
  for loc in "$@"; do
    if [ -f "${root}/$loc" ]; then
      found="${root}/$loc"
      break
    fi
  done
  if [ -z "$found" ]; then
    for loc in "$@"; do
      candidate=$(find "$root" -type f -path "*/$loc" -print -quit)
      if [ ! -z "$candidate" ]; then
        found="$candidate"
        break
      fi
    done
  fi
  echo "$found"
}

configureLabel() {
  local user vendor
  partitionLabel=${partitionLabel:-$(blkid -o value -s LABEL -- "$selectedIsoFile")}
  case $filesystemType in
  vfat)
    # Label to uppercase, otherwise some DOS systems won't work properly
    partitionLabel=${partitionLabel^^}
    # FAT32 labels have maximum 11 chars
    partitionLabel=${partitionLabel:0:11}
    ;;
  exfat)
    # EXFAT labels have maximum 15 chars
    partitionLabel=${partitionLabel:0:15}
    ;;
  ntfs)
    # NTFS labels have maximum 32 chars
    partitionLabel=${partitionLabel:0:32}
    ;;
  ext2 | ext3 | ext4)
    # EXT labels have maximum 16 chars
    partitionLabel=${partitionLabel:0:16}
    ;;
  f2fs)
    # F2FS labels have maximum 512 glyphs
    # approximated with 512 chars
    partitionLabel=${partitionLabel:0:512}
    ;;
  *)
    echowarn "Unexpected partition type '$filesystemType'." "$openTicketMessage"
    ;;
  esac
  # Fallback to "USER_VENDOR" if format
  if [[ "$action" == format ]]; then
    user=${SUDO_USER:-$USER}
    vendor=$(lsblk -dno VENDOR "$selectedDevice" 2> /dev/null)
    vendor=${vendor:-FLASH}
    partitionLabel=${partitionLabel:-"${user^^}_${vendor^^}"}
  else
    partitionLabel=${partitionLabel:-BOOTISO}
  fi
  if [ -z "${userVars['label']}" ]; then
    echogood "Partition label automatically set to '$partitionLabel'." \
      "You can explicitly set the label with $(boldify '-L, --label')."
  else
    echogood "Partition label manually set to '$partitionLabel'."
  fi

}

# $1: The name of the package command to check.
checkpkg() {
  local answer
  if ! hasPackage "$1"; then
    echowarn "Command '$1' not found! Should be in package '${commandPackages["$1"]}'."
    if [ ! -z "$pkgmgr" ]; then
      read -r -n1 -p "${logPrefixEmpty}Attempt installation? (y/n)> " answer
      echo
      case $answer in
      y | Y)
        if ! $pkgmgr "${commandPackages["$1"]}"; then
          failAndExit "${exitStatus[MISDEP]}" "Installation of dependency '$1' failed." \
            "Perhaps this dependency has a slightly different name on your distribution." \
            "Find it and install manually."
        else
          if ! hasPackage "$1"; then
            failAndExit "${exitStatus[MISDEP]}" "Program '$1' is not accessible in the \$PATH environment even though the package ${commandPackages["$1"]} has just been installed."
          fi
        fi
        ;;
      *)
        failAndExit "${exitStatus[MISDEP]}" "Missing dependency '$1'."
        ;;
      esac
    else
      failAndExit "${exitStatus[MISDEP]}" "Missing dependency '$1'."
    fi
  fi
}

# $1: The string by which elements will be joined.
# $2-* : the elements to join
joinBy() {
  local IFS=$1
  shift
  echo "$*"
}

# $1: The element to check.
# $2-* : the list to check against.
containsElement() {
  local e match="$1"
  shift
  for e; do [[ "$e" == "$match" ]] && return 0; done
  return 1
}

initDevicesList() {
  local -a devices
  local device
  mapfile -t devices < <(lsblk -dno NAME)
  devicesList=()
  for device in "${devices[@]}"; do
    if [ "$(getDeviceType "/dev/$device")" == "usb" ] || [ "$disableUSBCheck" == 'true' ]; then
      devicesList+=("$device")
    fi
  done
}

listDevicesTable() {
  # Run udevadm settle
  local lsblkCmd='lsblk -d -l -o NAME,MODEL,VENDOR,SIZE,TRAN,HOTPLUG'
  initDevicesList
  if [ "$disableUSBCheck" == 'true' ]; then
    echoinfo "Listing drives available in your system:"
  else
    echoinfo "Listing USB devices available in your system:"
  fi
  if [ "${#devicesList[@]}" -gt 0 ]; then
    $lsblkCmd "${devicesList[@]/#/\/dev\/}" | sed "s/^/$logPrefixEmpty/"
    return 0
  else
    echowarn "Couldn't find any USB drives on your system." \
      "If one is physically plugged in, it's likely that it has been ejected and should be reconnected." \
      "You can check the availability of USB drives with $(boldify "$scriptName -l")."
    return 1
  fi
}

parseArguments() {
  enableUserFlag() {
    userFlags["$1"]=true
  }
  setUserVar() {
    userVars["$1"]=$2
  }
  local key
  local isEndOfOptions=false
  local wrongOptions
  while [[ $# -gt 0 ]]; do
    key="$1"
    if [ "$isEndOfOptions" == false ]; then
      case $key in
      # ACTIONS
      -h | --help | help)
        enableUserFlag 'help'
        shift
        ;;
      -v | --version)
        enableUserFlag 'version'
        shift
        ;;
      -l | --list-usb-drives)
        enableUserFlag 'list-usb-drives'
        shift
        ;;
      -p | --probe)
        enableUserFlag 'probe'
        shift
        ;;
      -f | --format)
        enableUserFlag 'format'
        shift
        ;;
      -i | --inspect)
        enableUserFlag 'inspect'
        shift
        ;;
      --dd | --icopy)
        enableUserFlag 'install-image-copy'
        shift
        ;;
      --mrsync)
        enableUserFlag 'install-mount-rsync'
        shift
        ;;
      # OPTIONS
      --dd-bs)
        if (($# < 2)); then
          failAndExit "${exitStatus[SYNOPSISNC]}" \
            "Missing value for '$1' flag. Please provide a number of bytes, see dd(1)."
        fi
        setUserVar 'dd-bs' "$2"
        shift 2
        ;;
      --local-bootloader)
        enableUserFlag 'local-bootloader'
        shift
        ;;
      --remote-bootloader)
        if (($# < 2)); then
          failAndExit "${exitStatus[SYNOPSISNC]}" \
            "Missing value for '$1' flag. Please provide a version following MAJOR.MINOR pattern. ex: '4.10'."
        fi
        setUserVar 'remote-bootloader' "$2"
        shift 2
        ;;
      --gpt)
        enableUserFlag 'gpt'
        shift
        ;;
      -y | --assume-yes)
        enableUserFlag 'assume-yes'
        shift
        ;;
      -d | --device)
        if (($# < 2)); then
          failAndExit "${exitStatus[SYNOPSISNC]}" "Missing value for '$1' flag. Please provide a device."
        fi
        setUserVar 'device' "$2"
        shift 2
        ;;
      --partype)
        if (($# < 2)); then
          failAndExit "${exitStatus[SYNOPSISNC]}" "Missing value for '$1' flag. Please provide a partition type."
        fi
        setUserVar 'partype' "${2}"
        shift 2
        ;;
      -t | --type)
        if (($# < 2)); then
          failAndExit "${exitStatus[SYNOPSISNC]}" "Missing value for '$1' flag. Please provide a filesystem type."
        fi
        setUserVar 'type' "${2,,}" #lowercased
        shift 2
        ;;
      -L | --label)
        if (($# < 2)); then
          failAndExit "${exitStatus[SYNOPSISNC]}" "Missing value for '$1' flag. Please provide a label."
        fi
        setUserVar 'label' "$2"
        shift 2
        ;;
      --hash-file)
        if (($# < 2)); then
          failAndExit "${exitStatus[SYNOPSISNC]}" "Missing value for '$1' flag. Please provide a hash file."
        fi
        setUserVar 'hash-file' "$2"
        shift 2
        ;;
      -J | --no-eject)
        enableUserFlag 'no-eject'
        shift
        ;;
      -H | --no-hash-check)
        enableUserFlag 'no-hash-check'
        shift
        ;;
      -a | --autoselect)
        enableUserFlag 'autoselect'
        shift
        ;;
      -M | --no-mime-check)
        enableUserFlag 'no-mime-check'
        shift
        ;;
      --no-usb-check)
        enableUserFlag 'no-usb-check'
        shift
        ;;
      --no-size-check)
        enableUserFlag 'no-size-check'
        shift
        ;;
      --force-hash-check)
        enableUserFlag 'force-hash-check'
        shift
        ;;
      --no-wimsplit)
        enableUserFlag 'no-wimsplit'
        shift
        ;;
      --)
        isEndOfOptions=true
        shift
        ;;
      -*)
        if [[ "$isEndOfOptions" == false ]]; then
          if [[ "$key" =~ ^-- ]]; then
            failAndExit "${exitStatus[SYNOPSISNC]}" "Unknown option: $(boldify "$key")."
          # Handle stacked options
          elif [[ "$key" =~ ^-["$shortOptions"]{2,}$ ]]; then
            shift
            local options=${key#*-}
            local -a extractedOptions
            mapfile -t extractedOptions < <(echo "$options" | grep -o . | xargs -d '\n' -n1 printf '-%s\n')
            set -- "${extractedOptions[@]}" "$@"
          else
            printf "\\e[0;31m%s\\e[m" "$scriptName: Unknown options: "
            printf '%s.' "$key" | GREP_COLORS='mt=00;32:sl=00;31' grep --color=always -P "[$shortOptions]"
            if [[ "$key" =~ ^-[a-zA-Z0-9]+$ ]]; then
              wrongOptions=$(printf '%s' "${key#*-}" | grep -Po "[^$shortOptions]" | tr -d '\n')
              if [ ${#key} -eq 2 ]; then
                echowarn "$(boldify "$wrongOptions") flag were not recognized."
              else
                echowarn "$(boldify "$wrongOptions") flags were not recognized."
              fi
            fi
            failAndExit "${exitStatus[SYNOPSISNC]}"
          fi
        else
          setUserVar 'iso-file' "$1"
          shift
        fi
        ;;
      *)
        setUserVar 'iso-file' "$1"
        shift
        ;;
      esac
    else
      setUserVar 'iso-file' "$1"
      break
    fi
  done
}

checkPackages() {
  local pkg
  for pkg in "${commandDependencies[@]}"; do
    checkpkg "$pkg"
  done
  # test grep supports -P option
  if ! echo 1 | grep -P '1' &>/dev/null; then
    failAndExit "${exitStatus[MISDEP]}" \
      "You're using an old version of grep which does not support perl regular expression (-P option)."
  fi
}

# $1 : the folder name prefix
# print the name of the new folder if operation succeeded, fails otherwise
createMountFolder() {
  local tmpFileTemplate
  if ((EUID == 0)); then
    tmpFileTemplate="$mountRoot/$1-XXX"
  else
    tmpFileTemplate="$tempRoot/$1-XXX"
  fi
  mktemp -d "$tmpFileTemplate"
  local status=$?
  if [ ! $status -eq 0 ]; then
    failAndExit "${exitStatus[INTERNALIO]}" "Failed to create temporary mount point with pattern '$tmpFileTemplate'."
  fi
}

createTempFile() {
  local tmpFileTemplate="$tempRoot/$1-XXX"
  mktemp "$tmpFileTemplate"
  local status=$?
  if [ ! $status -eq 0 ]; then
    failAndExit "${exitStatus[INTERNALIO]}" "Failed to create temporary file."
  fi
}

# $1 : a device block
# Returns "usb" if device is USB, "ata" for SATA and "other" otherwise
getDeviceType() {
  local deviceType
  deviceType=$(lsblk --nodeps -nlo TRAN "$1")
  echo "${deviceType:-other}"
}

deviceIsDisk() {
  lsblk --nodeps -o NAME,TYPE "$1" | grep -q disk
  return $?
}

selectDevice() {
  local _selectedDevice
  chooseDevice() {
    echoinfo "Select the device corresponding to the USB device you want to make bootable: $(joinBy ',' "${devicesList[@]}")" \
      "\n${logPrefixEmpty}Type CTRL+D to quit."
    read -r -p "${logPrefixEmpty}Select device id> " _selectedDevice
    echo
    if containsElement "$_selectedDevice" "${devicesList[@]}"; then
      selectedDevice="/dev/$_selectedDevice"
    else
      if containsElement "$_selectedDevice" "" "exit"; then
        echoinfo "Exiting on user request."
        exit 0
      else
        failAndExit "${exitStatus[MISDEV]}" "The drive $_selectedDevice does not exist."
      fi
    fi
  }
  handleDeviceSelection() {
    if [ ${#devicesList[@]} -eq 1 ] && [ "$disableUSBCheck" == false ]; then
      # autoselect
      if [ "$disableConfirmation" == false ] || { [ "$disableConfirmation" == 'true' ] && [ "$autoselect" == 'true' ]; }; then
        local selected="${devicesList[0]}"
        echogood "Autoselecting '$selected' (only USB device candidate)"
        selectedDevice="/dev/$selected"
      else
        chooseDevice
      fi
    else
      chooseDevice
    fi
  }
  if [ -z "$selectedDevice" ]; then
    # List all hard disk drives
    if listDevicesTable; then
      handleDeviceSelection
    else
      failAndExit "${exitStatus[NODEV]}"
    fi
  fi
  selectedPartition="${selectedDevice}1"
}

assertDeviceIsOK() {
  failDevice() {
    echoerr "$1"
    listDevicesTable
    echoerr "Exiting..."
    exit 1
  }
  local -r device=$1
  if [ ! -e "$device" ]; then
    failDevice "The selected device '$device' does not exist."
  fi
  if [ ! -b "$device" ]; then
    failDevice "The selected device '$device' is not a valid block file."
  fi
  if [ ! -d "/sys/block/$(basename "$device")" ] || ! deviceIsDisk "$device"; then
    failAndExit "${exitStatus[BADDEV]}" \
      "The selected device '$device' is either unmounted or not a disk (might be a partition or loop)." \
      "Select a disk instead or reconnect the USB device." \
      "You can check the availability of USB drives with $(boldify "$scriptName -l")."
  fi
}

assertDeviceIsUSB() {
  local deviceType
  if [ "$disableUSBCheck" == 'true' ]; then
    echowarn "USB check has been disabled. Skipping."
    return 0
  fi
  deviceType=$(getDeviceType "$selectedDevice")
  if [ "$deviceType" != "usb" ]; then
    echoerr "The device you selected is not connected via USB (found TRAN: '$deviceType') and the operation was therefore canceled."
    echowarn "Use $(boldify '--no-usb-check') to bypass this policy at your own risk."
    echoerr "Exiting..."
    exit 1
  fi
  echogood "The selected device '$selectedDevice' is connected through USB."
}

assertISOSize() {
  local -r device=$1
  local -r iso=$2
  if [ "$disableSizeCheck" == 'true' ]; then
    echowarn "Size check has been disabled. Skipping."
    return 0
  fi
  if [ "$(blockdev --getsz "$iso")" -gt "$(blockdev --getsz "$device")" ]; then
    echoerr "The image is larger than the selected device '$device' and the operation was therefore canceled."
    echowarn "Use $(boldify '--no-size-check') to bypass this policy at your own risk."
    echoerr "Exiting..."
    exit 1
  fi
}

shouldWipeUSBKey() {
  local answer='y'
  echowarn "About to wipe the content of device '$selectedDevice'."
  if [ "$disableConfirmation" == false ]; then
    read -r -p "${logPrefixEmpty}Are you sure you want to proceed? (y/n)> " answer
  else
    echowarn "Bypassing confirmation with $(boldify '-y, --assume-yes')."
  fi
  if [ "$answer" == 'y' ]; then
    return 0
  else
    return 1
  fi
}

# $1: partType - MBR or GPT
# $2: notBootable - true or false
createPartitionTable() {
  local partitionOptions="label: gpt"
  local sfdiskCommand='sfdisk'
  local sfdiskVersion
  local tableType=$1
  local notBootable=$2
  local -A gptTypeCodes mbrTypeCodes
  sfdiskVersion=$(sfdisk -v | grep -Po '\d+\.\d+')
  makeSfdiskCommand() {
    # Retrocompatibility for 'old' sfdisk versions
    if compute "$sfdiskVersion >= 2.28"; then
      sfdiskCommand='sfdisk -W always'
    fi
  }
  initGPT() {
    partitionOptions="label: gpt\n"
    gptTypeCodes=(
      ['vfat']="${gptPartitionCodes[wdp]}"
      ['exfat']="${gptPartitionCodes[wdp]}"
      ['ntfs']="${gptPartitionCodes[wdp]}"
      ['ext2']="${gptPartitionCodes[lfd]}"
      ['ext3']="${gptPartitionCodes[lfd]}"
      ['ext4']="${gptPartitionCodes[lfd]}"
      ['f2fs']="${gptPartitionCodes[lfd]}"
    )
    if [ "$notBootable" == false ]; then
      if [[ "${isoInspection['supportsEFIBoot']}" == true && "${isoInspection['hasWimFile']}" == false ]]; then
        # Windows UEFI boot partitions must be of type "Windows Data Partition",
        # otherwise bug with "Drivers not found"
        # Set typecode to EFI System Partition
        gptTypeCodes[vfat]="${gptPartitionCodes[efi]}"
      else
        failAndExit "${exitStatus[INTERNALST]}" "GPT partition tables are not compatible with legacy BIOS boot."
      fi
    fi
    partitionOptions+="type=${partitionType:-${gptTypeCodes[$filesystemType]}}"
  }
  initMBR() {
    partitionOptions="label: dos\n"
    mbrTypeCodes=(['vfat']='c' ['exfat']='7' ['ntfs']='7' ['ext2']='83' ['ext3']='83' ['ext4']='83' ['f2fs']='83')
    partitionOptions+="$selectedPartition : start=2048, type=${partitionType:-${mbrTypeCodes[$filesystemType]}}"
  }
  makeSfdiskCommand
  case "$tableType" in
  GPT) initGPT ;;
  MBR) initMBR ;;
  *) failAndExit "${exitStatus[INTERNALST]}" "Unexpected partition scheme '$1'" ;;
  esac
  if [[ "$notBootable" == false && "$tableType" == MBR ]]; then
    partitionOptions+=", bootable"
  fi
  echogood "Creating $tableType partition table with 'sfdisk' v$sfdiskVersion..."
  echo -e "$partitionOptions" | $sfdiskCommand "$selectedDevice" |& indentAll || failAndExit "${exitStatus[INTERNALIO]}" \
    "Failed to write USB device $tableType partition table."
  partprobe "$selectedDevice" # Refresh partition table
  syncdev
}

# $1: notBootable - true or false
#     default false
partitionUSB() {
  local tableType notBootable=${1:-false}
  # These options always end up with the label flag setter
  local -Ar mkfsOpts=(
    ['vfat']="-v -F 32 -n" # Fat32 mode
    ['exfat']="-n"
    ['ntfs']="-Q -c 4096 -L" # Quick mode + cluster size = 4096 for Syslinux support
    ['ext2']="-O ^64bit -L"  # Disabling pure 64 bits compression for syslinux compatibility
    ['ext3']="-O ^64bit -L"  # see https://www.syslinux.org/wiki/index.php?title=Filesystem#ext
    ['ext4']="-O ^64bit -L"
    ['f2fs']="-l"
  )
  unmountPartitions() {
    local partition
    # unmount any partition on selected device
    mapfile -t devicePartitions < <(grep -oP "^\\K$selectedDevice\\S*" /proc/mounts)
    for partition in "${devicePartitions[@]}"; do
      if ! umount "$partition" >/dev/null; then
        failAndExit "${exitStatus[INTERNALIO]}" \
          "Failed to unmount $partition. It's likely that the partition is busy."
      fi
    done
  }
  eraseDevice() {
    echoinfo "Erasing contents of '$selectedDevice'..."
    # clean signature from selected device
    wipefs --all --force "$selectedDevice" &>/dev/null
    # erase drive
    dd if=/dev/zero of="$selectedDevice" bs=512 count=1 conv=notrunc status=none |&
      indentAll ||
      failAndExit "${exitStatus[INTERNALIO]}" "Failed to erase USB device." \
        "It's likely that the device has been ejected and needs to be reconnected." \
        "You can check the availability of USB drives with $(boldify "$scriptName -l")."
    syncdev
  }
  formatPartition() {
    # format
    echogood "Creating $filesystemType partition on '$selectedPartition'..."
    # shellcheck disable=SC2086
    mkfs -V -t "$filesystemType" ${mkfsOpts[$filesystemType]} "$partitionLabel" "$selectedPartition" |&
      indentAll ||
      failAndExit "${exitStatus[INTERNALIO]}" "Failed to create $filesystemType partition on USB device."
  }
  if shouldWipeUSBKey; then
    unmountPartitions
    eraseDevice
    if [ "$shouldMakePartition" == 'true' ]; then
      if [[ "$enforceGPT" == true && (${isoInspection['supportsEFIBoot']} == true || "$notBootable" == true) ]]; then
        tableType=GPT
      else
        tableType=MBR
      fi
      createPartitionTable $tableType "$notBootable"
      formatPartition
    fi
  else
    failAndExit "${exitStatus[USERABORT]}" "Canceling operation."
  fi
}

mountUSB() {
  local type="$filesystemType"
  usbMountPoint=$(createMountFolder usb) || exit "$?"
  temporaryAssets+=("$usbMountPoint")
  echoinfo "Created USB device mount point at '$usbMountPoint'"
  if ! mount -t "$type" "$selectedPartition" "$usbMountPoint" >/dev/null; then
    failAndExit "${exitStatus[INTERNALIO]}" "Could not mount USB device."
  fi
}

# Requires variable "i" in scope
updateProgress() {
  local sp="/-\\|"
  # print when launched from terminal
  if tty -s; then
    printf "\\b%s" "${sp:i++%${#sp}:1}"
  fi
  sleep 0.25
}

cleanProgress() {
  # print when launched from terminal
  if tty -s; then
    printf "\\b%s\\n" " "
  fi
}

syncWithProgress() {
  local -i i=1
  local -i status
  local syncPid
  local statusFile
  statusFile=$(createTempFile "bootiso-sync-status")
  temporaryAssets+=("$statusFile")
  syncdev &
  syncPid=$!
  echo -n "$scriptName: Synchronizing writes on device '${selectedDevice}'   "
  while [ -e "/proc/$syncPid" ]; do
    updateProgress
  done
  cleanProgress
  status=$(cat "$statusFile")
  if [ ! "$status" -eq 0 ]; then
    failAndExit "${exitStatus[INTERNALIO]}" "Sync call failed."
  fi
}

copyWithRsync() {
  rsyncWithProgress() {
    local -i i=1
    local statusFile
    local wimFile="$elTorinoMountPoint/sources/install.wim"
    local rsyncOptions=""
    local status
    statusFile=$(createTempFile "bootiso-rsync-status")
    temporaryAssets+=("$statusFile")
    if [ -f "$wimFile" ]; then
      if [ "$disableWimsplit" == false ]; then
        rsyncOptions="--exclude sources/install.wim"
        echogood "Detected a Windows install.wim file, which will be handled by 'wimlib-imagex' utility."
      else
        echowarn "Detected a Windows install.wim file but wimsplit has been disabled with $(boldify '--no-wim-split') option."
      fi
    fi
    (
      # shellcheck disable=SC2086
      rsync -r -q -I --no-links --no-perms --no-owner --no-group $rsyncOptions "$elTorinoMountPoint"/. "$usbMountPoint"
      status=$?
      cleanProgress
      if ((status == 0)) && [ -f "$wimFile" ] && [ "$disableWimsplit" == false ]; then
        echo
        wimlib-imagex split "$wimFile" "$usbMountPoint/sources/install.swm" 1024 |& indentAll
      fi
      echo "$status" >"$statusFile"
    ) &
    pid=$!
    echo -n "$scriptName: Copying files from image to USB device with 'rsync'    "
    while [ -e "/proc/$pid" ]; do
      updateProgress
    done
    cleanProgress
    status=$(cat "$statusFile")
    if [ ! "$status" -eq 0 ]; then
      failAndExit "${exitStatus[INTERNALIO]}" "Copy command with 'rsync' failed."
    fi
  }
  checkpkg 'rsync'
  rsyncWithProgress
  syncWithProgress
}

copyWithDD() {
  ddWithProgress() {
    local -i i=1
    local statusFile
    local status
    statusFile=$(createTempFile "bootiso-status")
    temporaryAssets+=("$statusFile")
    (
      dd if="$selectedIsoFile" of="$selectedDevice" bs="$ddBusSize" status=none
      echo "$?" >"$statusFile"
    ) &
    pid=$!
    echo -n "$scriptName: Copying files from image to USB device with 'dd'    "
    while [ -e "/proc/$pid" ]; do
      updateProgress
    done
    cleanProgress
    status=$(cat "$statusFile")
    if [ ! "$status" -eq 0 ]; then
      failAndExit "${exitStatus[INTERNALIO]}" "Copy command with 'dd' failed."
    fi
  }
  ddWithProgress
  syncWithProgress
}

installSyslinuxVersion() {
  local versions
  local minor
  local filename
  local rootURL="https://mirrors.edge.kernel.org/pub/linux/utils/boot/syslinux/Testing"
  local syslinuxArchive
  local assetURL
  local status
  local selectedSyslinuxVersion=$1
  local abortingMessage="Aborting SYSLINUX installation and resuming with local install."
  checkConnexion() {
    status=$(curl -sLIo /dev/null -w "%{http_code}" "$rootURL")
    if [ "$status" != 200 ]; then
      if [ "$status" == 000 ]; then
        failAndExit "${exitStatus[HOSTUNR]}" "kernel.org is unreachable. You don't seem to have an internet connection." \
          "Please try again later or use $(boldify '--local-bootloader') to force usage of the local SYSLINUX version."
        return 9
      else
        echowarn "Couldn't GET $rootURL." \
          "Received status code '$status'." \
          "$openTicketMessage" \
          "$abortingMessage"
        return 10
      fi
    fi
    return 0
  }
  findMinorVersions() {
    local syslinuxInstallDir
    versions="$(curl -sL "$rootURL" | grep -oP 'href="\K\d+\.\d+(?=/")' | sort --version-sort)"
    if (($? != 0)); then
      echowarn "Couldn't GET $rootURL." \
        "Aborting syslinux installation and resuming with local install."
      return 10
    elif [ -z "$versions" ]; then
      echoerr "Couldn't parse the result of $rootURL." \
        "This is not expected: please open a ticket at $ticketsurl." \
        "$abortingMessage"
      return 11
    fi
    minor=$(echo "$versions" | grep -E "^$selectedSyslinuxVersion" | grep "^${selectedSyslinuxVersion%.}" | tail -n 1)
    if [ -z "$minor" ]; then
      echoerr "Version '$selectedSyslinuxVersion' is not available at kernel.org."
      return 8
    fi
    return 0
  }
  findMatchedRelease() {
    filename=$(curl -sL "$rootURL/$minor/" | grep -oP 'href="\Ksyslinux-\d+\.\d+-\w+\d+\.tar\.gz(?=")' | sort --version-sort | tail -n1)
    if [ -z "$filename" ]; then
      echoerr "Couldn't find '$filename'."
      return 11
    fi
    assetURL="$rootURL/$minor/$filename"
    syslinuxArchive=$cacheRoot/$filename
    return 0
  }
  downloadMatchedVersion() {
    if [ -e "$syslinuxArchive" ]; then
      echogood "Found '$syslinuxArchive' in cache."
      return 0
    fi
    if curl -sL -o "$syslinuxArchive" "$assetURL"; then
      if [ -f "$syslinuxArchive" ]; then
        echogood "Download of '$syslinuxArchive' completed ($(du -h "$syslinuxArchive" | awk '{print $1}'))"
      else
        echowarn "Missing file '$syslinuxArchive'." \
          "This is not expected: please open a ticket at $ticketsurl." \
          "$abortingMessage"
        return 10
      fi
    else
      echowarn "Couldn't get '$assetURL'." \
        "This is not expected: please open a ticket at $ticketsurl." \
        "$abortingMessage"
      return 10
    fi
    return 0
  }
  extractMatchedVersion() {
    if tar -xf "$syslinuxArchive" -C "$tempRoot"; then
      syslinuxInstallDir="$tempRoot/$(basename "${syslinuxArchive%.tar.gz}")"
      temporaryAssets+=("$syslinuxInstallDir")
    else
      rm "$syslinuxArchive"
      return 11
    fi
  }
  configureSyslinuxInstall() {
    local extlinuxBin
    local mbrBin
    extlinuxBin=$(findFileFromPatterns "$syslinuxInstallDir" 'bios/extlinux/extlinux' 'extlinux/extlinux' 'extlinux')
    mbrBin=$(findFileFromPatterns "$syslinuxInstallDir" 'bios/mbr/mbr.bin' 'mbr/mbr.bin' 'mbr.bin')
    if [ -z "$extlinuxBin" ]; then
      echowarn "Couldn't find 'extlinux' binary in installation folder." \
        "$abortingMessage"
      return 10
    fi
    if [ -z "$mbrBin" ]; then
      echowarn "Couldn't find 'mbr.bin' in installation folder." \
        "$abortingMessage"
      return 10
    fi
    syslinuxInstall['mbrBin']="$mbrBin"
    syslinuxInstall['extBin']="$extlinuxBin"
    return 0
  }
  checkpkg 'curl'
  inferSyslinuxVersion
  checkConnexion || return "$?"
  findMinorVersions || return "$?"
  findMatchedRelease || return "$?"
  downloadMatchedVersion || return "$?"
  extractMatchedVersion || return "$?"
  configureSyslinuxInstall || return "$?"
  echogood "SYSLINUX version '$minor' temporarily set for installation."
}

installBootloader() {
  local syslinuxFolder
  local syslinuxConfig
  local -i versionsMatch=0
  local localSyslinuxVersion
  inferSyslinuxVersion() {
    localSyslinuxVersion=$(syslinux --version |& grep -oP '(\d+\.\d+)')
    if [ "$selectedBootloaderVersion" != 'auto' ]; then
      syslinuxVersion="$selectedBootloaderVersion"
    else
      syslinuxVersion=${isoInspection['syslinuxVer']:-"$localSyslinuxVersion"}
    fi
  }
  # return 0 : install from kernel.org
  # return 1+: install from local
  checkSyslinuxVersion() {
    if [ "$localBootloader" == true ]; then
      echogood "Enfoced local SYSLINUX bootloader at version '$localSyslinuxVersion'."
      return 1
    fi
    if [ -z "$syslinuxVersion" ]; then
      return 1
    fi
    if [ "$selectedBootloaderVersion" != 'auto' ]; then
      echoinfo "Searching for SYSLINUX V$syslinuxVersion remotely."
      if ! installSyslinuxVersion "$syslinuxVersion"; then
        if [ ! -z "${isoInspection['syslinuxVer']}" ]; then
          echowarn "Falling back to image SYSLINUX version '${isoInspection['syslinuxVer']}'"
          syslinuxVersion="${isoInspection['syslinuxVer']}"
          installSyslinuxVersion "${isoInspection['syslinuxVer']}"
          return $?
        else
          return 1
        fi
      else
        return 0
      fi
    fi
    echoinfo "Found local SYSLINUX version '$localSyslinuxVersion'"
    compute "$localSyslinuxVersion == ${isoInspection['syslinuxVer']}" >/dev/null
    versionsMatch=$?
    if ((versionsMatch == 0)); then
      echogood "image SYSLINUX version matches local version."
      return 1
    else
      local -i status
      echowarn "image SYSLINUX version doesn't match local version." \
        "Scheduling download of version $syslinuxVersion..."
      if ! installSyslinuxVersion "$syslinuxVersion"; then
        echowarn "Falling back to local SYSLINUX version '$localSyslinuxVersion'."
        syslinuxVersion="$localSyslinuxVersion"
        return 1
      fi
    fi
  }
  setSyslinuxLocation() {
    local isoFolder
    local isolinuxConfig
    if [[ "${isoInspection['syslinuxConf']}" =~ isolinux.cfg ]]; then
      isolinuxConfig="$usbMountPoint${isoInspection['syslinuxConf']}"
      isoFolder=$(dirname "$isolinuxConfig")
      syslinuxConfig="$isoFolder/syslinux.cfg"
      mv "$isolinuxConfig" "$syslinuxConfig"
      echoinfo "Found ISOLINUX config file at '$isolinuxConfig'." \
        "Moving to '$syslinuxConfig'."
    else
      syslinuxConfig="$usbMountPoint${isoInspection['syslinuxConf']}"
    fi
    syslinuxFolder=$(dirname "$syslinuxConfig")
  }
  installWtLocalExtlinux() {
    syslinuxInstall=(['mbrBin']="$foundSyslinuxMbrBinary" ['extBin']='extlinux')
    syslinuxVersion="$localSyslinuxVersion"
    echoinfo "Installing SYSLINUX bootloader in '$syslinuxFolder' with local version '$syslinuxVersion'..."
    rsync --no-links --no-perms --no-owner --no-group -I "$foundSyslinuxBiosFolder"/*.c32 "$syslinuxFolder" |&
      indentAll ||
      echowarn "SYSLINUX could not install C32 BIOS modules."
    syncdev
    echogood "C32 BIOS modules successfully installed."
    ${syslinuxInstall['extBin']} --stupid --install "$syslinuxFolder" |& indentAll || failAndExit "${exitStatus[INTERNALTP]}" \
      "SYSLINUX bootloader could not be installed."
    syncdev
  }
  installWtKernelOrgExtlinux() {
    echoinfo "Installing SYSLINUX bootloader in '$syslinuxFolder' with kernel.org version '$syslinuxVersion'..."
    if ! ${syslinuxInstall['extBin']} --stupid --install "$syslinuxFolder" |& indentAll; then
      echowarn "Could not run SYSLINUX '$syslinuxVersion' from kernel.org." \
        "Attempting with local SYSLINUX install..."
      installWtLocalExtlinux >/dev/null
    fi
    syncdev
  }
  installMasterBootRecordProg() {
    dd bs=440 count=1 conv=notrunc status=none if="${syslinuxInstall['mbrBin']}" of="$selectedDevice" |&
      indentAll ||
      failAndExit "${exitStatus[INTERNALIO]}" "Failed to install Master Boot Record program."
    syncdev
    echogood "Succesfully installed Master Boot Record program."
  }
  inferSyslinuxVersion
  setSyslinuxLocation
  checkSyslinuxVersion
  case $? in
  0) installWtKernelOrgExtlinux ;;
  *) installWtLocalExtlinux ;;
  esac
  echogood "Successfully installed SYSLINUX bootloader at version '$syslinuxVersion'."
  installMasterBootRecordProg
}

checkAction() {
  local -ra actions=('help' 'version' 'format' 'install-image-copy' 'install-mount-rsync' 'list-usb-drives' 'inspect' 'probe')
  local -a enabledActions=()
  local act
  for act in "${actions[@]}"; do
    if [ "${userFlags[$act]}" == 'true' ]; then
      enabledActions+=("$act")
    fi
  done
  if ((${#enabledActions[@]} == 0)); then
    action='install-auto'
  elif ((${#enabledActions[@]} == 1)); then
    action=${enabledActions[0]}
  else
    failAndExit "${exitStatus[SYNOPSISNC]}" \
      "You cannot invoke multiple actions at once: $(joinBy '+' "${enabledActions[@]}")."
  fi
}

checkUserVars() {
  # check partition type
  if [ ! -z "${userVars['type']}" ]; then
    if [ "${userVars['type'],,}" == fat32 ]; then
      userVars['type']=vfat
    fi
    local fsType=${vfat:-${userVars['type']}}
    if ! containsElement "$fsType" "${supportedFS[@]}"; then
      failAndExit "${exitStatus[SYNOPSISNC]}" "FS type '$fsType' not supported." \
        "Supported FS types: $(joinBy "," "${supportedFS[*]}")."
    fi
    if ! containsElement "$action" "install-mount-rsync" "format"; then
      failAndExit "${exitStatus[SYNOPSISNC]}" "Cannot set partition type with action $(boldify "$action")." \
        "$(boldify '-t, --type') is compatible with $(boldify format) and $(boldify install) 'Mount-Rsync' only."
    fi
    if ! command -v "mkfs.$fsType" &>/dev/null; then
      failAndExit "${exitStatus[MISDEP]}" \
        "Program 'mkfs.$fsType' could not be found on your system." \
        "Please install it and retry."
    fi
  fi
  # check device
  if [ ! -z "${userVars['device']}" ]; then
    if [[ ! "${userVars['device']}" =~ '/dev/' ]] && [ -e "/dev/${userVars['device']}" ]; then
      userVars['device']="/dev/${userVars['device']}"
    fi
    assertDeviceIsOK "${userVars['device']}"
  fi
  if [ ! -z "${userVars['remote-bootloader']}" ] && [[ ! "${userVars['remote-bootloader']}" =~ ^[0-9]+\.[0-9]+$ ]]; then
    failAndExit "${exitStatus[SYNOPSISNC]}" \
      "Remote bootloader version '${userVars['remote-bootloader']}' set with $(boldify '--remote-bootloader') doesn't follow MAJOR.MINOR pattern." \
      "Valid examples are 4.10, 6.02"
  fi
  # Check dd-bs
  if [[ -n "${userVars[dd-bs]}" && ! ${userVars[dd-bs]} =~ ^[0-9]+[kMGT]?$ ]]; then
    failAndExit "${exitStatus[SYNOPSISNC]}" "$(boldify '--dd-bs') argument must be a valid block size quantifier, e.g. 512k, 2M."
  fi
}

checkUserFlags() {
  # Autoselect security
  if [ "${userFlags['autoselect']}" == 'true' ] && [ "${userFlags['no-usb-check']}" == 'true' ]; then
    failAndExit "${exitStatus[MISDEP]}" \
      "You cannot set $(boldify '-a, --autoselect') while disabling USB check with $(boldify '--no-usb-check')"
  fi
  if [ "${userFlags['no-hash-check']}" == 'true' ] && [ "${userFlags['force-hash-check']}" == 'true' ]; then
    failAndExit "${exitStatus[SYNOPSISNC]}" \
      "You cannot combine $(boldify '--no-hash-check') and $(boldify '--force-hash-check')"
  elif [ "${userFlags['no-hash-check']}" == 'true' ] && [ -n "${userVars['hash-file']}" ]; then
    failAndExit "${exitStatus[SYNOPSISNC]}" \
      "You cannot combine $(boldify '--no-hash-check') and $(boldify '--hash-file')"
  fi
  # warnings (only with sudo)
  if ((EUID == 0)); then
    # Eject format
    if [ "${userFlags['no-eject']}" == true ] && [ "$action" == "format" ]; then
      echowarn "You don't need to prevent device ejection through $(boldify '-J') flag with 'format'."
    fi
    # Warn autoselecting while assume yes is false
    if [ "${userFlags['autoselect']}" == 'true' ] && [ "${userFlags['assume-yes']}" == false ]; then
      echowarn "$(boldify '-a, --autoselect') is enabled by default when $(boldify '-y, --asume-yes') is not set."
    fi
  fi
}

checkFlagMatrix() {
  local key
  for key in "${!userVarsCompatibilityMatrix[@]}"; do
    if [ ! -z "${userVars[$key]}" ]; then
      #shellcheck disable=SC2086
      if ! containsElement "$action" ${userVarsCompatibilityMatrix[$key]}; then
        if [ "$key" == "iso-file" ]; then
          failAndExit "${exitStatus[SYNOPSISNC]}" \
            "$(boldify $action) doesn't require any positional arguments."
        else
          failAndExit "${exitStatus[SYNOPSISNC]}" \
            "$(boldify "$action") action doesn't support $(boldify --$key) modifier."
        fi
      fi
    fi
  done
  for key in "${!userFlagsCompatibilityMatrix[@]}"; do
    if [ ! -z "${userFlags[$key]}" ]; then
      #shellcheck disable=SC2086
      if ! containsElement "$action" ${userFlagsCompatibilityMatrix[$key]}; then
        failAndExit "${exitStatus[SYNOPSISNC]}" \
          "$(boldify $action) action doesn't support $(boldify --$key) modifier."
      fi
    fi
  done
}

cleanup() {
  removeTempAsset() {
    if [[ "$1" =~ ^$tempRoot ]] || [[ "$1" =~ ^$mountRoot ]]; then
      if [ -d "$1" ]; then
        rm -rf "$1"
      elif [ -f "$1" ]; then
        rm "$1"
      else
        echowarn "Skipping deletion of unexpected asset type at '$1'."
      fi
    else
      echowarn "Skipping deletion of unexpected temporary asset at '$1'."
    fi
  }
  ejectDevice() {
    if [[ "$operationSuccess" =~ ^install ]]; then
      if [[ "$noDeviceEjection" == false ]]; then
        if eject "$selectedDevice" |& indentAll; then
          echogood "USB device succesfully ejected." \
            "You can safely remove it!"
        else
          echowarn "Failed to eject device '$selectedDevice'."
        fi
      else
        echoinfo "USB device ejection skipped with $(boldify '-J, --no-eject')."
      fi
    fi
  }
  if ((EUID == 0)); then
    local asset
    umountElTorino
    umountUSB
    for asset in "${temporaryAssets[@]}"; do
      removeTempAsset "$asset"
    done
    ejectDevice
  fi
}

assignInternalVariables() {
  # Command argument
  selectedIsoFile=${userVars['iso-file']:-''}
  # Option flags
  disableConfirmation=${userFlags['assume-yes']:-'false'}
  autoselect=${userFlags['autoselect']:-'false'}
  enforceGPT=${userFlags['gpt']:-'false'}
  localBootloader=${userFlags['local-bootloader']:-'false'}
  disableMimeCheck=${userFlags['no-mime-check']:-'false'}
  disableUSBCheck=${userFlags['no-usb-check']:-'false'}
  disableSizeCheck=${userFlags['no-size-check']:-'false'}
  disableHashCheck=${userFlags['no-hash-check']:-'false'}
  forceHashCheck=${userFlags['force-hash-check']:-'false'}
  disableWimsplit=${userFlags['no-wimsplit']:-'false'}
  # Vars flags
  filesystemType=${userVars['type']:-'vfat'}
  partitionType=${userVars['partype']}
  hashFile=${userVars['hash-file']:-''}
  selectedDevice=${userVars['device']:-''}
  partitionLabel=${userVars['label']:-''}
  selectedBootloaderVersion=${userVars['remote-bootloader']:-'auto'}
  ddBusSize=${userVars['dd-bs']:-'4M'}
  # Action-dependent flags
  case $action in
  install-*)
    hasActionDuration='true'
    expectingISOFile='true'
    requiresRoot='true'
    noDeviceEjection=${userFlags['no-eject']:-'false'}
    ;;
  format)
    hasActionDuration='true'
    expectingISOFile='false'
    requiresRoot='true'
    ;;
  version)
    hasActionDuration='false'
    expectingISOFile='false'
    requiresRoot='false'
    ;;
  help | list-usb-drives)
    hasActionDuration='false'
    expectingISOFile='false'
    requiresRoot='false'
    ;;
  inspect | probe)
    hasActionDuration='false'
    expectingISOFile='true'
    requiresRoot='true'
    ;;
  *)
    failAndExit "${exitStatus[INTERNALST]}" "Unhandled action $(boldify "$action")."
    ;;
  esac
}

startTimer() {
  startTime=$(date +%s)
}

stopTimerAndPrintLapsed() {
  endTime=$(date +%s)
  echogood "Took $((endTime - startTime)) seconds to perform $(boldify "$action") action."
}

runSecurityAssessments() {
  configureLabel
  selectDevice
  startTimer
  assertDeviceIsOK "$selectedDevice"
  assertDeviceIsUSB
  assertISOSize "$selectedDevice" "$selectedIsoFile"
}

# $1: mountPoint
# $2: inspect syslinux? true or false
inspectPartition() {
  local mountPoint="$1" wimFile
  local supportsEFIBoot hasWimFile syslinuxBin syslinuxConf syslinuxVer
  supportsEFIBoot=${isoInspection[supportsEFIBoot]:-false}
  hasWimFile=${isoInspection[hasWimFile]:-false}
  syslinuxBin=${isoInspection[syslinuxBin]}
  syslinuxConf=${isoInspection[syslinuxConf]}
  syslinuxVer=${isoInspection[syslinuxVer]}
  local -a sysLinuxLocations=('boot/syslinux/syslinux.cfg' 'syslinux/syslinux.cfg' 'syslinux.cfg' 'boot/syslinux/extlinux.conf'
    'boot/syslinux/extlinux.cfg' 'boot/extlinux/extlinux.conf' 'boot/extlinux/extlinux.cfg' 'syslinux/extlinux.conf'
    'syslinux/extlinux.cfg' 'extlinux/extlinux.conf' 'extlinux/extlinux.cfg' 'extlinux.conf' 'extlinux.cfg')
  local -a isoLinuxLocations=('boot/isolinux/isolinux.cfg' 'isolinux/isolinux.cfg' 'isolinux.cfg' 'boot/syslinux/isolinux.cfg' 'syslinux/isolinux.cfg')
  inspectSyslinux() {
    syslinuxBin=$(matchFirstExpression "$mountPoint" 'syslinux.bin' 'isolinux.bin' 'extlinux.bin' 'boot.bin' 'extlinux' 'syslinux' 'isolinux')
    if [ ! -z "$syslinuxBin" ]; then
      syslinuxVer=$(strings "$syslinuxBin" | grep -E 'ISOLINUX|SYSLINUX|EXTLINUX' | grep -oP '(\d+\.\d+)' | awk 'NR==1{print $1}')
    fi
    syslinuxConf=$(findFileFromPatterns "$mountPoint" "${sysLinuxLocations[@]}")
    if [ -z "$syslinuxConf" ]; then
      syslinuxConf=$(matchFirstExpression "$mountPoint" 'syslinux.cfg' 'extlinux.conf' 'extlinux.cfg')
    fi
    if [ -z "$syslinuxConf" ]; then
      syslinuxConf=$(findFileFromPatterns "$mountPoint" "${isoLinuxLocations[@]}")
      syslinuxConf=${syslinuxConf:-$(firstMatchInFolder "$mountPoint" 'isolinux.cfg')}
    fi
  }
  inspectEFICapabilities() {
    local hasEfiRoot
    local hasEfiFile
    hasEfiRoot=$(find "$mountPoint" -type d -iname 'efi' -print -quit)
    hasEfiFile=$(find "$mountPoint" -type f -ipath '*/efi/*.efi' -prune -print -quit)
    if [ ! -z "$hasEfiFile" ] && [ ! -z "$hasEfiRoot" ]; then
      supportsEFIBoot=true
    fi
  }
  inspectWindows() {
    wimFile="$mountPoint/sources/install.wim"
    if [[ -e "$wimFile" ]]; then
      hasWimFile=true
    fi
  }
  inspectEFICapabilities
  inspectWindows
  isoInspection[supportsEFIBoot]=$supportsEFIBoot
  isoInspection[hasWimFile]=$hasWimFile
  if [[ $2 == true ]]; then
    inspectSyslinux
    isoInspection[syslinuxConf]="$syslinuxConf"
    isoInspection[syslinuxBin]="$syslinuxBin"
    isoInspection[syslinuxVer]="$syslinuxVer"
  fi
}

# $1: mountPoint
mountElTorinoFile() {
  local mountPoint="$1"
  if ! mount -r -o loop -- "$selectedIsoFile" "$mountPoint" >/dev/null; then
    failAndExit "${exitStatus[INTERNALIO]}" "Could not mount image file."
  else
    temporaryAssets+=("$mountPoint")
  fi
}

inspectHybridImage() {
  local diskReport scheme
  local startSector
  local supportsEFIBoot supportsBIOSBoot
  inspectMBRPartTable() {
    # Look for the first ESP partition
    startSector=$(echo "$diskReport" | jq ".partitiontable.partitions | map(select(.type==\"${mbrPartitionCodes[efi]}\"))[0].start | select (.!=null)")
    # If ESP found, look for first bootable
    if [[ -n "$startSector" ]]; then
      supportsEFIBoot=true
    else
      supportsEFIBoot=false
    fi
    startSector=$(echo "$diskReport" | jq '.partitiontable.partitions | map(select(.bootable==true))[0].start | select (.!=null)')
    if [[ -n "$startSector" ]]; then
      supportsBIOSBoot=true
    else
      supportsBIOSBoot=false
    fi
  }
  inspectGPTPartTable() {
    # In GPT mode, UEFI is theoretically the only possible boot mode
    startSector=$(echo "$diskReport" | jq ".partitiontable.partitions | map(select(.type==\"${gptPartitionCodes[efi]}\"))[0].start | select (.!=null)")
    supportsBIOSBoot=false
    if [[ -n "$startSector" ]]; then
      supportsEFIBoot=true
    else
      supportsEFIBoot=false
    fi
  }
  diskReport=$(sfdisk -lJ -- "$selectedIsoFile" 2>/dev/null)
  if (($? != 0)); then
    failAndExit "${exitStatus[INTERNALIO]}" "sfdisk couldn't read the partition table on the image file, which is likely corrupted."
  fi
  scheme=$(echo "$diskReport" | jq -r '.partitiontable.label')
  case $scheme in
  dos) inspectMBRPartTable ;;
  gpt) inspectGPTPartTable ;;
  esac
  isoInspection[supportsBIOSBoot]="$supportsBIOSBoot"
  isoInspection[supportsEFIBoot]="$supportsEFIBoot"
}

inspectElTorinoImage() {
  local mountPoint
  mountPoint=$(createMountFolder iso) || exit "$?"
  mountElTorinoFile "$mountPoint"
  inspectPartition "$mountPoint" true
  unmountPartition "$mountPoint"
}

inspectImageFile() {
  local isHybrid
  inspectImageFilesystem() {
    file -b -- "$selectedIsoFile" | grep -q '^ISO 9660 CD-ROM filesystem'
    if (($? == 0)); then
      isHybrid=false
    else
      isHybrid=true
    fi
  }
  inspectImageFilesystem
  if [[ $isHybrid == true ]]; then
    inspectHybridImage
  else
    inspectElTorinoImage
  fi
  isoInspection[isHybrid]=$isHybrid
}

inspectISOBootCapabilities() {
  local uefiCompatible=${isoInspection['supportsEFIBoot']}
  local syslinuxCompatible=false
  if [ "${isoInspection['supportsEFIBoot']}" == true ]; then
    if [ "$filesystemType" != "vfat" ]; then
      echowarn "Found UEFI boot capabilities but you selected '$filesystemType' type, which is not compatible with UEFI boot." \
        "Be warned that only legacy boot might work, if any."
    else
      uefiCompatible=true
      echogood "UEFI boot check validated. Your USB will work with UEFI boot."
    fi
  fi
  if [[ "$enforceGPT" == true && "${isoInspection['supportsEFIBoot']}" == false ]]; then
    echowarn "$(boldify '--gpt') option ignored because image file solely supports legacy BIOS boot, which requires MBR."
  fi
  if [ ! -z "${isoInspection['syslinuxConf']}" ]; then
    syslinuxCompatible=true
    addSyslinuxBootloader=true
    if [ ! -z "${isoInspection['syslinuxVer']}" ]; then
      echogood "Found SYSLINUX config file and binary at version ${isoInspection['syslinuxVer']}."
    elif [ ! -z "${isoInspection['syslinuxBin']}" ]; then
      echogood "Found SYSLINUX config file and binary with unknown version."
    else
      echogood "Found SYSLINUX config file."
    fi
    echogood "A SYSLINUX booloader will be installed on your USB device."
  fi
  if [[ "$syslinuxCompatible" == false && "$uefiCompatible" == false ]]; then
    failAndExit "${exitStatus[MISBOOTCAP]}" \
      "The selected image is not hybrid, doesn't support UEFI or legacy booting with SYSLINUX." \
      "Therefore, it cannot result in any successful booting with $scriptName." \
      "Consider following the documentation provided with this image file."
  fi
}

checkSyslinuxInstall() {
  checkpkg 'syslinux'
  if ! command -v extlinux >/dev/null; then
    failAndExit "${exitStatus[MISDEP]}" \
      "Your distribution doesn't ship 'extlinux' with the 'syslinux' package." \
      "Please install 'extlinux' and try again."
  fi
  foundSyslinuxBiosFolder=$(find "$syslinuxLibRoot" -type d -path '*/bios' -print -quit)
  foundSyslinuxMbrBinary=$(findFileFromPatterns "$syslinuxLibRoot" 'bios/mbr.bin' 'mbr.bin')
  if [ -z "$foundSyslinuxBiosFolder" ]; then
    failAndExit "${exitStatus[MISDEP]}" \
      "Could not find a SYSLINUX bios folder containing c32 bios module files on this system."
  fi
  if [ -z "$foundSyslinuxMbrBinary" ]; then
    failAndExit "${exitStatus[MISDEP]}" "Could not find a SYSLINUX MBR binary on this system."
  fi
}

printISOBootCapabilities() {
  local uefiCompatible=${isoInspection[supportsEFIBoot]}
  local biosCompatible=${isoInspection[supportsBIOSBoot]}
  local syslinuxCompatible=false
  local isHybrid=${isoInspection['isHybrid']}
  local syslinux='SYSLINUX'
  local localSyslinuxVersion
  if [ ! -z "${isoInspection['syslinuxConf']}" ]; then
    syslinuxCompatible=true
  fi
  if [ ! -z "${isoInspection['syslinuxVer']}" ]; then
    syslinux+=" ${isoInspection['syslinuxVer']}"
  fi
  echoinfo "Reporting '$(basename "$selectedIsoFile")' boot capabilities:"
  if [ "$isHybrid" == false ] && [ "$syslinuxCompatible" == false ] && [ "$uefiCompatible" == false ]; then
    echoerr "The selected image is not hybrid, doesn't support UEFI or legacy BIOS booting nor SYSLINUX." \
      "It cannot result in any successful booting with $scriptName."
  elif [ "$isHybrid" == false ] && [ "$syslinuxCompatible" == true ] && [ "$uefiCompatible" == false ]; then
    echogood "The selected image is not hybrid, but supports legacy BIOS booting with $syslinux." \
      "It should boot with $scriptName in $(boldify install) 'Automatic' and 'Mount-Rsync' modes with BIOS-boot capable PCs."
  elif [ "$isHybrid" == false ] && [ "$syslinuxCompatible" == false ] && [ "$uefiCompatible" == true ]; then
    echogood "The selected image is not hybrid, but supports UEFI boot." \
      "It should boot with $scriptName in $(boldify install) 'Automatic' and 'Mount-Rsync' modes with modern UEFI-capable PCs."
  elif [ "$isHybrid" == false ] && [ "$syslinuxCompatible" == true ] && [ "$uefiCompatible" == true ]; then
    echogood "The selected image is not hybrid, but supports legacy BIOS booting with $syslinux and UEFI boot." \
      "It should boot with $scriptName in $(boldify install) 'Automatic' and 'Mount-Rsync' modes with any PCs."
  elif [ "$isHybrid" == true ] && [ "$syslinuxCompatible" == false ] && [[ "$biosCompatible" == false ]] && [ "$uefiCompatible" == false ]; then
    echowarn "The selected image is hybrid, but doesn't support UEFI or legacy BIOS bootloader." \
      "It should boot with $scriptName in $(boldify install) 'Automatic' and 'Image-Copy' modes, but $scriptName is not aware of its booting scheme."
  elif [ "$isHybrid" == true ] && [ "$syslinuxCompatible" == true ] && [ "$uefiCompatible" == false ]; then
    echogood "The selected image is hybrid and supports legacy BIOS booting with $syslinux." \
      "It should boot with $scriptName in $(boldify install) 'Automatic' and 'Image-Copy' modes with BIOS-boot capable PCs."
  elif [ "$isHybrid" == true ] && [ "$biosCompatible" == true ] && [ "$uefiCompatible" == false ]; then
    echogood "The selected image is hybrid and supports legacy BIOS booting." \
      "It should boot with $scriptName in $(boldify install) 'Automatic' and 'Image-Copy' modes with BIOS-boot capable PCs."
  elif [ "$isHybrid" == true ] && [ "$syslinuxCompatible" == false ] && [ "$uefiCompatible" == true ]; then
    echogood "The selected image is hybrid and supports UEFI boot." \
      "It should boot with $scriptName in $(boldify install) 'Automatic' and 'Image-Copy' modes with modern UEFI-capable PCs."
  elif [ "$isHybrid" == true ] && [ "$syslinuxCompatible" == true ] && [ "$uefiCompatible" == true ]; then
    echogood "The selected image is hybrid and supports legacy BIOS booting with $syslinux along with UEFI boot." \
      "It should boot with $scriptName in $(boldify install) 'Automatic' and 'Image-Copy' modes with any PCs."
  elif [ "$isHybrid" == true ] && [ "$biosCompatible" == true ] && [ "$uefiCompatible" == true ]; then
    echogood "The selected image is hybrid and supports legacy BIOS boot along with UEFI boot." \
      "It should boot with $scriptName in $(boldify install) 'Automatic' and 'Image-Copy' modes with any PCs."
  else
    echoerr "Wrong state. isHybrid: $isHybrid, biosCompatible: $biosCompatible, uefiCompatible: $uefiCompatible, syslinuxCompatible: $syslinuxCompatible"
  fi
  if [[ "$uefiCompatible" == false && ("$syslinuxCompatible" == true || "$biosCompatible" == true) ]]; then
    echowarn "You might have to enable CSM in your UEFI system for legacy BIOS-boot suport."
  fi
  localSyslinuxVersion=$(syslinux --version |& grep -oP '(\d+\.\d+)')
  if [ "$syslinuxCompatible" == true ] && [ ! -z "${isoInspection['syslinuxVer']}" ] && [ "$isHybrid" == false ]; then
    if compute "$localSyslinuxVersion == ${isoInspection['syslinuxVer']}"; then
      echogood "Furthermore, SYSLINUX version in the image file matches local version (${isoInspection['syslinuxVer']})."
    elif compute "${localSyslinuxVersion%.*} == ${isoInspection['syslinuxVer']%.*}"; then
      echoinfo "However, SYSLINUX version (${isoInspection['syslinuxVer']}) in the image file doesn't match the minor part of local version ($localSyslinuxVersion), which should not cause any problems."
    else
      echowarn "SYSLINUX version (${isoInspection['syslinuxVer']}) in the image file doesn't match the major part of local version ($localSyslinuxVersion)." \
        "$scriptName will try to download and execute this version from kernel.org, unless given the modifier $(boldify '--local-bootloader')." \
        "If that fails, it will attempt installation with the local version of SYSLINUX."
    fi
  fi
}

execProbe() {
  printISOBootCapabilities
  listDevicesTable
}

execWithRsync() {
  if [ "${isoInspection[isHybrid]}" == true ]; then
    failAndExit "${exitStatus[ASSERTFAIL]}" "You cannot set Mount-Rsync mode with a hybrid image file." \
      "Hybrid ISO or disk image files eventually contain multiple partitions and Mount-Rsync mode can only work with one."\
      "If you think this image file is not hybrid and this is a bug, please report at " \
      "${ticketsurl}."
  fi
  shouldMakePartition=true
  checkSyslinuxInstall
  inspectISOBootCapabilities
  runSecurityAssessments
  elTorinoMountPoint=$(createMountFolder iso) || exit "$?"
  mountElTorinoFile "$elTorinoMountPoint"
  partitionUSB false
  mountUSB
  copyWithRsync
  if [ "$addSyslinuxBootloader" == true ]; then
    installBootloader
  fi
}

execWithDD() {
  if [ "${isoInspection[isHybrid]}" == false ]; then
    failAndExit "${exitStatus[ASSERTFAIL]}" "You cannot set Image-Copy mode with a non-hybrid, 'El-Torino' image file." \
      "El-Torino image files don't have a partition table; and thus target device will not be recognized" \
      "by any boot system as a boot candidate. If you think this image file is hybrid and this is a bug, please report at "\
      "${ticketsurl}."
  fi
  shouldMakePartition=false
  runSecurityAssessments
  partitionUSB false
  copyWithDD
}

execAuto() {
  if [ "${isoInspection[isHybrid]}" == true ]; then
    echogood "Found hybrid image; choosing Image-Copy mode."
    execWithDD
  else
    echoinfo "Found non-hybrid image; inspecting image for boot capabilities..."
    execWithRsync
  fi
}

execFormat() {
  shouldMakePartition=true
  selectDevice
  startTimer
  configureLabel
  assertDeviceIsOK "$selectedDevice"
  assertDeviceIsUSB
  partitionUSB true
}

checkArguments() {
  checkAction
  checkUserVars
  checkUserFlags
}

main() {
  mkdir -p "$tempRoot"
  initPckgManager "$@"
  parseArguments "$@"
  checkArguments
  assignInternalVariables
  checkFlagMatrix
  checkPackages
  if [ "$requiresRoot" == 'true' ]; then
    checkSudo "$@"
    configureFolders
  fi
  if [ "$expectingISOFile" == 'true' ]; then
    assertISOIsOK
    if [ "$disableHashCheck" == false ]; then
      checkISOHash
    else
      echowarn "Skipping hash check with $(boldify '-H, --no-hash-check') flag"
    fi
    inspectImageFile
  fi
  case "$action" in
  'install-auto') execAuto "$@" ;;
  'install-image-copy') execWithDD "$@" ;;
  'install-mount-rsync') execWithRsync "$@" ;;
  'format') execFormat "$@" ;;
  'inspect') printISOBootCapabilities ;;
  'probe') execProbe "$@" ;;
  'list-usb-drives') listDevicesTable ;;
  'version') echo "$version" ;;
  'help') displayHelp ;;
  *) failAndExit "${exitStatus[INTERNALST]}" "(main) unexpected action $(boldify "$action")." ;;
  esac
  if [ "$hasActionDuration" == 'true' ]; then
    stopTimerAndPrintLapsed
  fi
  operationSuccess=$action
}

trap cleanup EXIT INT TERM
main "$@"
